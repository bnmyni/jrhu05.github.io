<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JerryFu&#39;s Blog</title>
  <subtitle>let us do sth interesting!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jrhu05.github.io/"/>
  <updated>2016-09-03T15:55:38.000Z</updated>
  <id>http://jrhu05.github.io/</id>
  
  <author>
    <name>jrhu05</name>
    <email>jrhu05@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用Scamper工具解析CAIDA trace数据</title>
    <link href="http://jrhu05.github.io/post/how-to-use-Scamper.html"/>
    <id>http://jrhu05.github.io/post/how-to-use-Scamper.html</id>
    <published>2016-09-03T15:35:04.000Z</published>
    <updated>2016-09-03T15:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>首先，需要到<a href="http://www.caida.org/tools/measurement/scamper/" target="_blank" rel="external">http://www.caida.org/tools/measurement/scamper/</a>网站下载工具的源码。</li>
<li>下载源码后，将源码复制到Linux系统下，准备编译。</li>
<li>打开linux命令行终端，定位到源码目录下，可以发现源码文件下有一个configure文件。</li>
<li>命令行终端下，输入./configure。</li>
<li>命令行终端下，输入make。</li>
<li>命令行终端下，输入make install。</li>
<li>至此，编译工作就结束了，你可以在usr/local/bin目录下看到编译好的工具。</li>
<li>直接在命令行终端输入sc_analysis_dump等相应的命令就可以解析文件了。</li>
<li>一般的解析文件的命令格式为sc_analysis_dump ﬁle1.warts，可用&gt;&gt;输入到指定的文件中，实例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc_analysis_dump ﬁle1.warts &gt;&gt; file1.txt</span><br></pre></td></tr></table></figure>
<p>下面附上详细使用说明：</p>
<p>sc_analysis_dump man page: convert scamper traces to something easily parsed with perl</p>
<p>NAME</p>
<p>　　sc_analysis_dump—dump of traceroute data in a format that is easily parsed.</p>
<p>SYNOPSIS</p>
<p>　　sc_analysis_dump [ −cCdeghHiloprst][ −D debug-count][ −G geo-server]<br>[ −S skip-count][file . ..]</p>
<p>DESCRIPTION</p>
<p>　　The sc_analysis_dump utility provides a dump of traceroute data in a format that is easily parsed by<br>scripts. Each line output contains a summary of a single trace, and includes the interfaces visited and the<br>delay of each response. The output format is identical to that of sk_analysis_dump from CAIDA, except that<br>it uses the scamper ﬁle API to read both arts++ ﬁles produced by skitter and warts ﬁles produced by scamper.</p>
<p>　　The options are as follows:</p>
<p>　　−c disables printing the cycle number in each line of output.</p>
<p>　　−C disables printing the comments about the output at the top of the output.</p>
<p>　　−d disables printing the destination address in each line of output.</p>
<p>　　−D debug-count</p>
<p>　　　　for each input ﬁle stop reading after the speciﬁed number of traces.</p>
<p>　　−e adds the response from the destination to each line of output.</p>
<p>　　−g use geographical data from netacuity.Not all builds of sc_analysis_dump support this option.</p>
<p>　　−G geo-server</p>
<p>　　　　speciﬁes the name of the netacuity server to use.</p>
<p>　　−h prints a help message and then exits.</p>
<p>　　−H disables printing the halt ﬁelds: whytraceroute halted and data for that reason.</p>
<p>　　−i disables printing the RTT to each hop, and howmanytries were required.</p>
<p>　　−l disables printing the list id in each line of output.</p>
<p>　　−o prints each line of output using the old format from sk_analysis_dump 1.0.</p>
<p>　　−p disables print path data in each line of output.</p>
<p>　　−r disables printing the data associated the response from a destination: the RTT,the TTL of the probe,and the TTL of the response.</p>
<p>　　−s disables printing the source IP address in each line of output.</p>
<p>　　−S skip-count</p>
<p>　　　　skips the deﬁned number of traces from each input ﬁle.</p>
<p>　　−t disables printing the timestamp of when the traceroute began.</p>
<p>OUTPUT</p>
<p>　　There is one trace per line. Fields are separated by a tab character.The output is structured into header ﬁelds<br>(2 to 6), reply ﬁelds (7 to 10) corresponding to the response receivedfrom the destination, halt ﬁelds (11 and<br>12), and hop ﬁelds (beginning at index13).</p>
<p>1.Key</p>
<p>　　Indicates the type of line and determines the meaning of the remaining ﬁelds. This will always be ’T’ for an IP trace.<br>FreeBSD 8.2 October 15, 2010 1SC_ANALYSIS_DUMP (1) FreeBSD General Commands Manual SC_ANALYSIS_DUMP (1)</p>
<p>2.Source</p>
<p>　　Source IP of skitter/scamper monitor performing the trace.</p>
<p>3.Destination </p>
<p>　　Destination IP being traced.</p>
<p>4.ListId</p>
<p>　　ID of the destination list containing this destination address. This value will be zero if no list ID<br>wasprovided. A ListId is a 32 bit unsigned integer.</p>
<p>5.CycleId</p>
<p>　　ID of current probing cycle. A cycle is a single run through a givenlist. A CycleId is a 32 bit<br>unsigned integer.For skitter traces, cycle IDs will be equal to or slightly earlier than the time-<br>stamp of the ﬁrst trace in each cycle. There is no standard interpretation for scamper cycle IDs.</p>
<p>　　This value will be zero if no cycle ID was provided.</p>
<p>6.Timestamp</p>
<p>　　Timestamp when trace begantothis destination.</p>
<p>7.DestReplied</p>
<p>　　Whether a response from the destination was received. The character R is printed if a reply was<br>received. The character N is printed if no reply was received. Since skitter sends a packet with a<br>TTL of 255 when it halts probing, it is still possible for the ﬁnal destination to send a reply and<br>for the HaltReasonData (see below) to not equal no_halt. Note: scamper does not perform this<br>last-ditch probing at TTL 255 by default.</p>
<p>8.DestRTT</p>
<p>　　The RTT (ms) of ﬁrst response packet from destination. This value is zero if DestReplied is N.</p>
<p>9.RequestTTL</p>
<p>　　TTL set in request packet which elicited a response (echo reply) from the destination. This value<br>is zero if DestReplied is N.</p>
<p>10.ReplyTTL</p>
<p>　　TTL found in reply packet from destination. This value is zero if DestReplied is N.</p>
<p>11.HaltReason</p>
<p>　　Asingle character corresponding to the reason, if any, why incremental probing stopped. Sis<br>printed if the destination was reached or there is no halt data. Uisprinted if an ICMP unreach-<br>able message was received. L is printed if a loop was detected. Gisprinted if the gaplimit was<br>reached.</p>
<p>12.HaltReasonData</p>
<p>　　Extra data about whyprobing halted. If HaltReason is S, the zero is output. If HaltReason is U,<br>the ICMP code of the unreachable message is printed. If HaltReason is L, the length of the loop<br>is printed. If HaltReason is G, the length of the gap is printed.</p>
<p>13.PathComplete</p>
<p>　　Whether all hops to destination were found. Cisprinted if the trace is complete, all hops are<br>found. I is printed if the trace is incomplete, at least one hop is missing (i.e., did not respond).<br>FreeBSD 8.2 October 15, 2010 2SC_ANALYSIS_DUMP (1) FreeBSD General Commands Manual SC_ANALYSIS_DUMP (1)</p>
<p>14.PerHopData</p>
<p>　　Response data for each hop. If multiple IP addresses respond at the same hop, response data for<br>each IP address are separated by semicolons:<br>IP,RTT,numTries (for only one responding IP) IP,RTT,numTries;IP,RTT,numTries;… (for multiple<br>responding IPs)<br>where IP is the IP address which sent a TTL expired packet, RTT is the RTT of the TTL expired<br>packet, and numTries is the number of tries before a response was receivedfrom the TTL.</p>
<p>　　This ﬁeld has the value ’q’ if there was no response at a hop.</p>
<p>EXAMPLES</p>
<p>　　The command:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc_analysis_dump ﬁle1.warts ﬁle2.warts</span><br></pre></td></tr></table></figure>
<p>will decode and print the traceroute objects in ﬁle1.warts, followed by the traceroute objects in ﬁle2.warts.</p>
<p>　　The command:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzcat ﬁle1.warts.gz | sc_analysis_dump</span><br></pre></td></tr></table></figure>
<p>will decode and print the traceroute objects in the uncompressed ﬁle supplied on stdin.</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;首先，需要到&lt;a href=&quot;http://www.caida.org/tools/measurement/scamper/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.caida.org/tools/measureme
    
    </summary>
    
      <category term="研究僧呀" scheme="http://jrhu05.github.io/categories/%E7%A0%94%E7%A9%B6%E5%83%A7%E5%91%80/"/>
    
    
      <category term="CAIDA" scheme="http://jrhu05.github.io/tags/CAIDA/"/>
    
      <category term="Scamper" scheme="http://jrhu05.github.io/tags/Scamper/"/>
    
      <category term="traceRoute" scheme="http://jrhu05.github.io/tags/traceRoute/"/>
    
  </entry>
  
  <entry>
    <title>安全感</title>
    <link href="http://jrhu05.github.io/post/safety-feeling.html"/>
    <id>http://jrhu05.github.io/post/safety-feeling.html</id>
    <published>2016-06-18T03:22:11.000Z</published>
    <updated>2016-06-18T05:27:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　我不是属于那种记忆力超群的人，很多过去的事情早已忘记，但有些小事，却印象深刻。</p>
<p>　　应该是在很小很小的时候，小到冰棍还是一毛钱一只，蛋筒五毛钱一只。我妈带我去集市，我坐在后座，夏天，她问我要不要吃个蛋筒，我当时是这么回答的“妈妈，我们家穷，我不吃蛋筒，我要吃冰棍”。然后我美滋滋的舔着冰棍，虽然很想吃蛋筒。我妈一个劲的夸我，真懂事，真乖。多年以后冷不惊的想到这件事，嗯，真懂事，真乖。</p>
<p>　　突然我意识到，从那个时候开始，我便习惯性的把自己的所有需求压缩到了最低的下界。因为，求更好的不确定能不能求得到，求最下边的往往都能到到，然后还会被夸懂事。这个习惯一直延续了很多年。</p>
<p>　　清贫本身并不会导致安全感的缺乏，诱因是对待其的态度。我写下来，是想给以后可能会为人父母的自己提个醒。</p>
<p>　　还有几个小事情挺有意思的，拿来说道说道。小学那会儿，孩子们都很单纯，农村嘛，大家都穷。有一次，不知道因为什么，我妈给我了五毛钱，五毛钱在我看来已经很多了。然后我跑去买了一件奢侈品“透明胶带”，对，你没看错，五毛钱一卷的透明胶带，我们这种低年级只用铅笔配橡皮的小屁孩对高年级圆珠笔配胶带纸的组合简直羡慕的不得了。然后根本舍不得用（其实是用不上，从小就喜欢装B，笑），当宝贝一样供着，找了个塑料袋，自制了一个降落伞（估计90后都玩过这个），那卷胶带就是坠在下面的重物。完了往天上扔着玩，结果扔了几次后，我去，居然挂树上了，我当时直接就傻眼了。然后放学回家的那个小队里不知谁带了个头喊“挂树上啦，谁能弄下来就是谁的”，我当时觉得那么高谁能够得到啊，我回家拿个小竹竿给它捅下来。结果居然真有个小孩，我到现在都能记得他麻溜脱鞋子的动作，居然会爬树，小学二三年纪啊，爬树啊，高级技能。就这么地，他把我那卷胶带给拿了下来，我死皮赖脸找他要，他不给。不给就算了，居然还跑，我后面追，根本追不上，我就这么地看着我人生中第一件奢侈品被人给硬生生的夺走。我知道，那仅仅是一卷透明胶带。我是一路哭回去的，快到家门了，抹抹眼泪，装作没事的样子，我妈也没问啥。<br>　　还有一件事我也记忆犹新，应该是四五年纪时候了吧。我三叔给了我一只应该是国外的极其豪华、漂亮、大气、上档次的自动铅笔，当时非常高兴和自豪，到处嘚瑟，从小就知道秀，笑。土鳖小学生，没见过啥大世面，到处传阅我的自动铅笔，我嘴上说着不要不要，心里偷着乐。结果等他们传到头，我拿回来想学着电视中何书桓那种很潇洒的写个字的时候，结果发现，笔芯挂不住了！拆开一看，少了个垫圈，用过自动铅笔的应该都知道，自动铅笔里在笔头部分有一个很小的橡胶做的垫圈，少了那个东西整个自动铅笔直接就废掉了，明明刚拿来的时候还是好好的。年幼的我未曾深想，还没有学会以最黑暗的方式去看待周围的人和事，天真的以为是不小心掉哪儿了，又不好意思明目张胆的找。那天我主动承担了所有的值日生任务，等大家都离开趴在地上一点一点仔细的找，我找了三遍，当然，怎么可能找得到。学校值班的老师负责锁门，急躁的催我赶紧打扫完走人，他还得锁门。我默默的搬板凳、洒水、扫地、倒垃圾、擦黑板，倒掉垃圾那一刻，我极其的难过。回家后我妈发现我闷闷不乐，问怎么了，我支支吾吾说了这个事情。我妈说“不就一只破自动铅笔嘛，明天我再去给你买一个！”，憋了半天，结果因为这一句话哭的稀里哗啦。然而，我直到最后也没等到那破自动铅笔，后来，我渐渐的觉得自己不应该拥有不属于自己的“贵重”的东西，再后来，这贵重的东西扩大到了人、友情、爱情。</p>
<p>　　我从未说过我童年是不快乐的，相反，小时候什么也不懂，什么也不会去多想。因此，关于物质的多寡，似乎并没有过多的影响我的童年。然而，当我逐渐的长大成熟，那些曾经不懂的小事一点点的清晰起来，然后副作用慢慢显现。</p>
<p>　　说完了物质基础，咱们再来聊聊上层建筑。</p>
<p>　　我仔细认真的思索了小学时候乃至初中残存的记忆碎片，我发现我的父亲几乎是缺位的，所有的记忆几乎都与我妈有关。关于他们了共同的记忆也有，争吵，以及打骂。他们好像一对冤家，针尖对麦芒，如此格格不入的两个人当初是如何走到一起且孕育了我，无从所知。他们不停的争吵，任何一点的小事情都会吵起来，莫名其妙且不分场合，然后愈演愈烈，我妈从来不会给人台阶下。于是我时常会经历这样的情况，前一秒钟还是无比温馨的一家人，后一秒似乎就一无所有。最严重的那次，他们直接明确的问我，以后跟谁，当时我并没识破这是他们俩拿我在互相赌气角力。我没说话，我谁都不会跟，你们都去死好了。他们前一天还在找着结婚证准备第二天就去民政局，结果第二天又和好了。这种突如其来的大起大落，让我愈发的觉得眼前的幸福是那么的不真实，然而你又什么也做不了。</p>
<p>　　我曾经一次次的试图从中调和，最无奈的时候居然拿我自己作为要挟。结果每次都是越帮越乱，换来的往往是“你个小屁孩死一边玩去！”，有次我小舅安慰我说，大人的世界你们小孩不懂。嗯，我不懂，所以我滚的远远的，看你们折腾，听天由命。但是这种感觉，我极其讨厌。小时候，包括到现在，我一直想不明白，毫无疑问，他们彼此对对方知根知底，究竟一个人会残忍到什么样的地步，才会竭尽全力挑捡那些最恶毒、最能伤到对方的话语，以至于把多年前的历史统统翻了出来，那些话就像武器，一把精致而又锋利的匕首，恶狠狠而又毫不犹豫的扎向对方的心脏。我很小的时候就明白了歇斯底里、丧心病狂的含义，生动形象。他们好像都很想让对方消失，让对方去死，我说的，是真的。我如果说我曾经很长一段时间最大的心愿是，一家人年三十坐在一起，安静的吃个饭、看春晚，你会不会觉得很好笑。我虽然不明白他们为什么要这么说这么做，可是我渐渐的也学会了这个技能，而且这个技能只对内不对外，我学会了挖掘出最亲近的人的弱点，然后和他们一样狠毒毫无保留，就像有毒的蜂刺一样。如果你没被蛰过，恭喜，你不属于最亲近人一列。附带的，我还学会了冷战这项隐藏技能。</p>
<p>　　很多时候，光明磊落、开朗阳光，是需要资本的。</p>
<p>　　安全感缺失带来的影响是缓慢而又可怕的，它像慢性毒药，虽不会暴毙身亡，但会一点点的累积，直到某一天出了大问题，你才会幡然醒悟，原来，它一直就在那里。毒副作用在年幼的时候会被年幼带来的福利——无知所保护，可一旦到了明事理的时期，懂得越多，副作用越强烈。其带来伴随品还有一个名为存在感缺失的物件。</p>
<p>　　缺乏安全感的人会极其在乎外物带来的满足感与短暂的安全感，他们会倾尽所有去追求，拥有了还好，可一旦哪天求而无所得，巨大的落差感便会显现。对于学习期间的青少年，这外物最具代表性的便是学习成绩。用我妈妈的话来说，我的学习从来没让他们操过心，认真、踏实，她还会时不时的把张三或李四家不争气天天上网打游戏的小孩拿过来和我对比一下，总之我就是她的骄傲。而我爸正好相反，我严重怀疑他们俩是不是商量好了的（笑），从来没有夸过我，不论怎么样的成绩他总是“还不错，戒骄戒躁，还能做更好，XXX又怎么怎么样……”，似乎永远没有天花板和尽头。后来我逐渐明白，永远这两个字本来就是骗人的。在这一白脸、一黑脸的双重刺激下，我变成了一个唯分数至上的标准“好学生”。于是高考的时候，我紧张的要死，整夜整夜的失眠，我输不起。然后，输了。我没有选择复读，因为我是个懦夫，不敢再面对一次高考，所以若干年后得知表弟要复读，很是佩服他。我们家人听从了我的意见，说明他们还是尊重我自己的选择的。因为高考的失利，我消沉了很长时间。</p>
<p>　　安全感低的人会极其的在乎周遭人的感受，尤其是陌生人。曾经有一段时间，我去超市买东西都是和声细语低三下四，生怕服务员会生气。偶尔去一次菜场或者大卖场，拿起东西从来不敢像我妈那样死命的砍价，一句“能不能便宜点？”，能就能，不能也不会纠缠。能避免的冲突，我会尽力避免。</p>
<p>　　这些东西也会渗透到对待朋友的关系。曾经拒绝二字对我而言很艰难，不擅长去拒绝一个人的要求，哪怕有些请求有些过分我也会竭尽所能去帮忙完成，哪怕会因此损伤到我自己的利益。因为我害怕一旦我拒绝，便会破坏这层关系。然而与之相对的是，我奉行的原则一直是不给人添麻烦，哪怕是很好的朋友，我不到万不得已不会去打扰他们。尽力去讨好别人，这是我曾经的错误。我本来以为这样是很对也很正确的，结果事与愿违，我的热心，他们说我老好人，更有甚认为我无底线，我不麻烦他们，他们说我高冷、装B。他们宁可围着对他们颐指气使的“王子”、“公主”摇尾，也不肯对我多说除了谢谢外哪怕一句话。曾经我对我一个好友抱怨这种事情，他说，你活该，这种人也就你自己觉得他们拿你当朋友。</p>
<p>　　我有很长很长一段时间，对婚姻、爱情是持绝对否定的态度，父母给我提供了一个绝佳的实例。如果爱情、婚姻就像他们这样的话，我宁愿一个人终老。后来遇到了心动的人，却怂的要死，大前提就把自己划入不可能的一列。她，变成了那只自动铅笔、透明胶带，贵重的东西。自然，结果也是不了了之。如果说以前可能是年幼无知瞎扯淡，然而，现在我是在认真的思考这个问题。</p>
<p>　　如果上面只是小打小闹，那么综合起来的长远效应可以用恐怖来形容。对自己一次次的苛求，泡沫越来越大，总有一天会炸掉，这一炸，几乎就是粉身碎骨。所有的成长都是伴随着痛苦，血和泪，详细的我懒得说，也不愿去回忆那段黑暗的日子。天才病，呵呵，我从来就不是什么狗屁天才。</p>
<p>　　我不知道该如何解决安全感缺失的问题，很可能我得一辈子与之相伴，但是问题必须得面对，逃避解决不了问题。慢慢来吧，总有法子的，或许以后多赚点钱、多去几个地方、多看几本书、找个女朋友、结婚、生子，这个问题自动的便解决了呢，又或许不会，谁知道呢。</p>
<p>　　不过有一点是肯定的，对待爱情，我会小心翼翼，对待婚姻，我会慎之又慎，对待孩子，我还没想好，我先把心理学入门这本大部头看完再说，笑。</p>
<p>　　我有时候想，如果当年我小嘴巴一撅，“五毛的蛋筒，我就要吃五毛的蛋筒”，事情会不会有一丁点的不一样呢，O(∩_∩)O~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　我不是属于那种记忆力超群的人，很多过去的事情早已忘记，但有些小事，却印象深刻。&lt;/p&gt;
&lt;p&gt;　　应该是在很小很小的时候，小到冰棍还是一毛钱一只，蛋筒五毛钱一只。我妈带我去集市，我坐在后座，夏天，她问我要不要吃个蛋筒，我当时是这么回答的“妈妈，我们家穷，我不吃蛋筒，我要
    
    </summary>
    
      <category term="琐事物语" scheme="http://jrhu05.github.io/categories/%E7%90%90%E4%BA%8B%E7%89%A9%E8%AF%AD/"/>
    
    
      <category term="安全感" scheme="http://jrhu05.github.io/tags/%E5%AE%89%E5%85%A8%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>青岛</title>
    <link href="http://jrhu05.github.io/post/qingdao.html"/>
    <id>http://jrhu05.github.io/post/qingdao.html</id>
    <published>2016-06-06T03:22:11.000Z</published>
    <updated>2016-06-09T08:50:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　青岛是一座无比温柔的城市，我很喜欢。</p>
<p>　　前段时间写论文写得有些烦了，很想出去溜达溜达，恰好家人去青岛参加会议，我也屁颠屁颠跟过去蹭吃蹭喝蹭玩。<br>　　如果想找旅游计划的话，可以直接戳这里：<a href="http://www.jerryfu.net/budget-traveler/" target="_blank" rel="external">六一儿童节，叔叔约不约</a>，最后我的行程和计划基本差不多，除了部分景点没去外。</p>
<h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><p>　　因为脑残的把8点航班看成了晚上8点，所以最后一天没法玩，因此6月1号儿童节那天便提前出发。下高铁，第一个感觉是，青岛的天好蓝啊，然后，火车站好漂亮啊，就像下面的样子。　　　</p>
<p><img src="/img/qingdao/qingdao-1.jpg" alt=""></p>
<p>　　然后便坐车前往住的地方，第一天因为想体验一下青旅所以提前定了口碑很好的一家，名字叫巢城青旅，在丹麦领事馆的旧址上，1910还是1913傻傻分不清，不过即使是1913那也100多年了，想想自己住的是一百多年历史的旅店，瞬间觉得高大上。</p>
<p>　　<br><img src="/img/qingdao/qingdao-2.jpg" alt=""></p>
<p>　　到内部一看发现很棒，比我想象的要好多了，我住的是四人间，惊喜的是居然是木头床，很像宿舍有木有。因为是旅游淡季，所以到最后只有我一个人来住，花一份的钱独享四人间，赚了哈哈。</p>
<p><img src="/img/qingdao/qingdao-3.jpg" alt=""></p>
<p>　　摆好东西后，到旅店里面溜达了一圈，发现青旅就是不一样，到处充满了文艺气息。你看那些个墙壁被贴的，满满当当的，还有手绘地图什么的，青旅简直太适合我这种装逼如风常伴吾身的伪文青臭屌丝了。</p>
<p><img src="/img/qingdao/qingdao-4.jpg" alt=""><br>￼</p>
<p><img src="/img/qingdao/qingdao-5.jpg" alt=""><br>￼</p>
<p><img src="/img/qingdao/qingdao-6.jpg" alt=""></p>
<p>　　出了旅店，第一站是火车站，青岛火车站有着很悠久的历史，虽然现在的火车站是后期重新修建的，但是任然保留了最初的那份韵味。在广场上漫步，很是惬意自在，修的像教堂的火车站我还是头一回见过，浓浓的欧式风格。</p>
<p><img src="/img/qingdao/qingdao-7.jpg" alt=""></p>
<p>　　离火车站不远便是栈桥，其实就是一个延伸到大海中的栈道，末端是一个小亭子。在栈桥旁边有一个观景台，观景台左手边既是栈桥，右边可能是个剧院，我没过去。全景照片有时候照出来异常的漂亮呢，只是因为手抖的缘故，右边的小哥好像被我照成外星人了……　</p>
<p><img src="/img/qingdao/qingdao-8.jpg" alt=""></p>
<p>　　从观景台到栈桥可以走人行步道，也可以从下方的礁石滩直接切过去，我当然是从礁石滩。在礁石滩发现一个有意思的现象，礁石上布满了贝壳，诺，那些白色的东西就是，很好玩的是，它们直接嵌到了石头里面，怎么也拿不出来。路上遇到两个海洋大学取样的同学，问了一下为什么会这样，结果它们是海洋生态学的，这东西可能和海洋地质学有关系，他们也不懂。</p>
<p><img src="/img/qingdao/qingdao-9.jpg" alt=""></p>
<p>　　看到上面图片中那些或站或弯腰或蹲下的人了吗？你猜他们在干什么？他们在逮小螃蟹、小龙虾、小鱼什么的，途中遇到一对当地的小朋友，一个男孩一个女孩，他们得意的向我炫耀着自己的战利品，嗯，一手一个小螃蟹。</p>
<p><img src="/img/qingdao/qingdao-10.jpg" alt=""></p>
<p>　　你说小朋友们抓着玩就算了，你们这些个叔叔阿姨爷爷奶奶也凑什么热闹，瞧那大叔专注的神情，不知道的还以为发现了啥宝贝呢。不过六一儿童节嘛，姑且就让他们这些每天疲于生活的人们找寻一下孩时的乐趣吧。</p>
<p><img src="/img/qingdao/qingdao-11.jpg" alt=""></p>
<p>　　优雅（装B）的我才不屑于和你们这些个凡人一起逮小螃蟹，哼，我要找个犄角旮旯的地儿偷偷抓个大的，嗯，口嫌体正直。这个是我抓的，对于男人，大即为浪漫！（我说的是螃蟹，别想歪了，笑）</p>
<p><img src="/img/qingdao/qingdao-12.jpg" alt="">   </p>
<p>　　还是刚刚那两个小孩，我看和男孩一起的那个萝莉挺可爱的，然后就有一句没一句的聊了起来，国小5年级。他们俩抓了好多小鱼小虾，我逗她说“小妹妹，抓那么多准备回去怎么吃啊？红烧还是清蒸？”，“我不是抓着吃的，我们玩玩之后就全部放掉”，“那你们抓他们还有什么意义？为什么又要放回去？”，“好玩啊，它跑来跑去的抓着很好玩，而且海虾子是养不活的，必须要放掉，它们是大海的孩子”。我瞬间被这个稚嫩的面庞给震住了，一个十来岁的小孩，居然说出了这么随意但是又这么有哲理的话语，大海的孩子，你们也是呢。</p>
<p>　　我抓了半天，抓到几只，全部扔到那两个孩子的小桶里面了。腰有些酸，伸伸腰，一抬头，看到一副无比美丽的图景。海边离机场比较近，航迹云配合着蓝天，勾勒出宁静与祥和，岁月静好，时光如画。</p>
<p><img src="/img/qingdao/qingdao-13.jpg" alt="">  </p>
<p>￼<br>　　这边是栈桥末端的小亭子，晚上灯光一打，倒也显得金碧辉煌。</p>
<p><img src="/img/qingdao/qingdao-14.jpg" alt="">    </p>
<p>　　从栈桥小亭子边一回身，便是青岛最繁华的一隅，整个城市的剪影浮现眼前，虽不及上海外滩那般耀人夺目，但也别有一番味道，配合着高楼在海面上的倒影，为这个城市最摩登的地方蓦地增添了几分柔情，似水。</p>
<p><img src="/img/qingdao/qingdao-15.jpg" alt="">    </p>
<p>　　我看天色已晚，便回身赶往旅店，途中遇到一个拉小提琴的艺人，青岛欧，很有创意的艺名，二维码、微博什么的一个不少，笑。我去过不少的城市，街头艺人只在西安、桂林、南宁这几个城市看到过，上海和南京从来没有见到过（抱个高音喇叭大哭大闹求救救我身患重病的家人顺带唱个催泪歌的不算），其实想想道理也很简单，大城市的人们都太匆忙了，急急的走，匆匆的赶，又有谁愿意驻足，哪怕不丢硬币，安安静静的听一小段？这些人，约莫只能在这样充满着文艺/文化气息的小城市出现吧。</p>
<p><img src="/img/qingdao/qingdao-16.jpg" alt=""></p>
<p>￼<br>　　回到旅馆后，迎接我的是老板娘家的狗，因为不养狗，所以对品名不是很熟悉。可能因为天气稍热的缘故，安静的趴在旅馆中为处不多的那块非木质楼梯上，也不正眼瞧我一下。</p>
<p><img src="/img/qingdao/qingdao-17.jpg" alt="">    </p>
<p>　　由于回到旅馆时间尚早，未到洗洗睡觉的时间，于是便在旅店里瞎转悠。凑巧的是，旅店一楼角落里有一个很小的酒吧，里面有着不知名的歌手在唱老狼的歌。我好奇的掀开遮帘，他们对我报以热切的微笑，倒使我有些局促，坐定后，一首歌未听完便匆匆逃离。烟，浓重的烟味，几乎所有人都在抽烟，呛人。在酒吧外头随意的摆放着几个大篮子，里面满满的都是酒瓶，有的落了一层的灰，应该都是酒吧里喝完剩下的，倒也成了一处风景。随手拿一瓶，Whiskey，没喝过，拍个照片装个B也是极好的。</p>
<p><img src="/img/qingdao/qingdao-18.jpg" alt="">    </p>
<p>　　我接着在走廊上看贴在墙上的那些纸片，有快乐、有伤心，突然觉得我很幸福，可以这样慢慢的品尝别人的喜怒哀乐。然后看到一个卡片，第一遍看感觉很感动，然后又看了一遍发觉有些不对头，然后又仔细看了一遍，直接黑线，两男的啊……</p>
<p><img src="/img/qingdao/qingdao-19.jpg" alt=""></p>
<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><p>　　早上很随意的睡懒觉，自由行很赞的就是可以随意的支配自己的时间，想玩就玩，想吃就吃，想睡就睡。反正，时间是我的。起床后看窗外的老街，突然发现窗台下面好像有暖气片！活的暖气片哎，第一次看到。嗯，活的。</p>
<p><img src="/img/qingdao/qingdao-20.jpg" alt=""></p>
<p>￼<br>　　早餐是一碗海鲜面，早上吃的清淡一点比较好。除了虾子、蛏子之外还还有些我叫不出名字来的小东西，总之很好吃，汤很鲜美，而且超便宜，才8块钱，辣么大一碗。</p>
<p><img src="/img/qingdao/qingdao-21.jpg" alt="">    </p>
<p>　　今天上午的行程安排是去五四广场和奥帆中心，本来打算坐车去的，结果一看离老城区也不远，于是便走了过去。青岛是一座充满着文艺气息的城市，诺，这不走着走着，忽的发现路边不知名的一个小房子墙面上装饰着美丽的花丛，处处充满着惊喜。</p>
<p><img src="/img/qingdao/qingdao-22.jpg" alt="">    </p>
<p>　　不知道是不是故意的，我在老城区看到的建筑都很是古朴。比如下面的这个警察局还有市人大常委，和我们这儿的活脱脱不是一个风格的，画风都不一样。</p>
<p><img src="/img/qingdao/qingdao-23.jpg" alt=""></p>
<p><img src="/img/qingdao/qingdao-24.jpg" alt=""></p>
<p>　　走着走着就到了五四广场，其实也没什么看的，只有一个红色的像火焰一样的雕塑，我就一个感觉，大。</p>
<p><img src="/img/qingdao/qingdao-25.jpg" alt=""></p>
<p>￼<br>　　我开始沿着岸边的防波堤慢慢的向奥帆中心走，发现了一处绝佳的拍摄全景的地方，随手来了一张，还算满意。我很喜欢拍全景照片，以后有钱攒个单反，天天拍全景，哈哈。</p>
<p><img src="/img/qingdao/qingdao-26.jpg" alt="">    </p>
<p>　　走着走着，路遇一对小情侣，都是很时髦的样子，在玩泡泡。恰巧那天有些微风，泡泡乘着风呼啦啦的来。我突然觉着这样图景很美，于是赶紧拍下来，他身后不远处是情人堤和灯塔，相得益彰。这种一幅照片一个故事的感觉我很喜欢，而且我很羡慕他们。</p>
<p><img src="/img/qingdao/qingdao-27.jpg" alt="">    </p>
<p>　　到了奥帆中心，也没什么可看的，标志性的大火炬就那回事，我也就一个感觉，大。倒是情人堤尽头的那座灯塔引起了我的兴趣，看着不算太远的灯塔，它在那里伫立了那么久，每天看我们人来人往。我突然觉得，它应该很孤独。</p>
<p><img src="/img/qingdao/qingdao-28.jpg" alt=""></p>
<p>　　逛得差不多了后有点饿，便随便吃了点，然后动身前往极地海洋世界。我坐的公交本来是朝着市里开的，结果不知怎么的，七拐八拐居然拐到了海边，可能你们永远无法体会那种走着走着突然看到大海的冲击。我很羡慕那些在海边生长的人们，走几步便可以看到如此美丽、广阔的风景，大海给了他们最宝贵的财富。</p>
<p><img src="/img/qingdao/qingdao-29.jpg" alt=""></p>
<p>￼<br>　　公交车沿着海边大道慢悠悠的开，不经意间一抬头，被这天给惊艳到了，蓝的让人嫉妒，南京的天，不忍直视。</p>
<p><img src="/img/qingdao/qingdao-30.jpg" alt="">    </p>
<p>　　去极地海洋馆，照例研究生不给半价，同是大学生，到哪儿都受歧视。我和那卖票的理论了半天，她非要说研究生不是大学生，我最后来了一句，“你说我不是大学生，那为什么坐火车能半价你不能啊？”，然后她就不理我了。以前从来没有去过正儿八经的海洋馆（水族馆），只在海底世界一类的TV节目里看到形形色色的海洋生物，本来上次去北海打算去海洋馆来着，结果门票太贵了，没舍得，这次头一回见到活的了，别提多兴奋了。不知道是不是因为水族箱灯光的缘故，照出来的照片大多数要么绿油油要么蓝盈盈的，不过，把快乐留在脑海里便足够了。看到了萌萌的蝠鲼，不过很伤心的，它们快灭绝了，我们国人认为它的鳃具有很高的药用价值，结果导致其被大量捕杀。这么可爱的生灵，希望我们的后代不要只能看到它们的标本。</p>
<p><img src="/img/qingdao/qingdao-31.jpg" alt="">    </p>
<p>　　对了，看到小丑鱼和海葵了，嘻嘻。</p>
<p><img src="/img/qingdao/qingdao-32.jpg" alt=""></p>
<p>　　不知怎么回事，居然看到了几只呱，海里面还有青蛙吗？一副“看什么看？！再看我弄死你”的表情&lt;(￣3￣)&gt; !</p>
<p><img src="/img/qingdao/qingdao-33.jpg" alt="">    </p>
<p>　　其中有一段很短的，都称不上隧道的海底隧道。可对我这样穷山沟里出来的没啥见识的人来说，已经足够了。看着海豹（海狮？傻傻分不清）在头顶上游来游去，很是有趣。这些个海豹很通人性，大概是每天看到人都看的腻歪了吧，大海豹对人爱理不理。反倒是小海豹，只要有人把手掌靠在玻璃上，就会有小海豹游过去，对着手狂亲。</p>
<p><img src="/img/qingdao/qingdao-34.jpg" alt=""></p>
<p>　　刺豚也看到了，萌萌的，这不是河豚，河豚是淡水鱼，被解说员狠狠教育的路过。我很想过去戳它一下，看它鼓得大大的样子。</p>
<p><img src="/img/qingdao/qingdao-35.jpg" alt=""></p>
<p>￼<br>　　最后看了一场海豚表演便结束了极地海洋世界的行程，恋恋不舍的离开。极地馆的旁边有一处小小的海滩，禁不住大海的诱惑，又跑过去玩了一会儿，依旧是蓝蓝的天和海，美得一塌糊涂。</p>
<p><img src="/img/qingdao/qingdao-36.jpg" alt="">    </p>
<p>　　站在礁石上，顺手又拍了一张全景，结果照片里又出现了一对小情侣。为什么我这个单身狗照的照片里老是有人赢，2333.</p>
<p><img src="/img/qingdao/qingdao-37.jpg" alt="">    </p>
<p>　　为了和家人会合，玩了会儿便回身。定的是府新，很贵，但不推荐，因为很烂。</p>
<h1 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h1><p>　　第三天早上去的是金沙滩，离住的地方蛮远的，公交车晃晃悠悠开了很长时间才到，搞得我以为已经出了青岛。不是很推荐大家去金沙滩，因为和青岛另外几个沙滩基本差不多，游客也不是很多，在沙滩闲逛的时候遇到了石油大学的一帮学生在拍毕业照，海边的毕业照，很棒。</p>
<p><img src="/img/qingdao/qingdao-38.jpg" alt=""></p>
<p>￼<br>　　这边的浪要比别的地方稍微大一点，姑且也算是感受到了大海狂野的一面，哈。黄黄的不是因为海水脏，海水比较浅，下面又是黄色的沙滩，所以显得黄黄的。</p>
<p><img src="/img/qingdao/qingdao-39.jpg" alt="">    </p>
<p>　　沙滩上又遇到几个小屁孩，他们拿个小铲子在挖沙子，熟络了后我也加入，我似乎和小孩子总能很快的热乎起来，大概有共同语言吧。挖着挖着，挖到了一个蛮漂亮的贝壳。</p>
<p><img src="/img/qingdao/qingdao-40.jpg" alt="">    </p>
<p>　　然后被一个大叔忽悠去坐了一次飞伞，贵贵贵，兴奋一会儿感觉也就那样，不是很刺激。不过在天上飘着，海风从脸庞刮过，很舒服。快艇也很刺激，但是我好像有些晕船，才坐了一小会儿就给颠的快吐了……</p>
<p><img src="/img/qingdao/qingdao-41.jpg" alt=""></p>
<p><img src="/img/qingdao/qingdao-42.jpg" alt=""></p>
<p>　　从金沙滩回到旅馆已经过了中午，匆匆吃了点饭便休息了一会儿。本来打算下午去海洋馆的，结果可能因为太累了，睡过头，醒来一看都快四点，海洋馆五点便关门。于是乎，便带家人重游五四广场、奥帆中心。在奥帆中心看见一种很神奇的小帆船，中间居然是空的，可能是为了高航速吧。</p>
<p><img src="/img/qingdao/qingdao-43.jpg" alt=""></p>
<p>￼<br>　　在奥帆中心靠里一点居然看到了海警船，好家伙，那叫一个大啊。这哪里是海警啊，分明就是海军舰艇，这家伙，最起码好几千吨的排水量啊。船头异常的锋利，和工作人员唠嗑说都有加装特殊的强化钢板，这是一言不合直接撞的节奏啊。果然，开疆拓土渔政局，保家卫国农业部。可惜那天不是开放日，没办法上去参观，第二天可以参观，结果我第二天只顾着玩把这事给忘了，遗憾。</p>
<p><img src="/img/qingdao/qingdao-44.jpg" alt="">    </p>
<p>　　有直升机停机坪、快艇、中远程雷达、矛枪、高压水炮（应该就是越南猴说的90c的水炮，90度……心疼越南猴）我能理解，可是为什么会有潜水艇啊？！潜水艇，潜水，潜……</p>
<p><img src="/img/qingdao/qingdao-45.jpg" alt="">    </p>
<p>　　奥帆中心大剧院挺漂亮的，有点神似悉尼歌剧院，当然，后者我没去过，笑。</p>
<p><img src="/img/qingdao/qingdao-46.jpg" alt=""></p>
<p>　　回程路上看见有人在用玫瑰花摆心形，一看就是准备表白的，拍一个，浪漫。我估计以后也只能给我喜欢的人提供这样的浪漫，不会很华丽，但是很暖心。</p>
<p><img src="/img/qingdao/qingdao-47.jpg" alt=""></p>
<p>￼<br>　　路上还看到了在别的城市从来没有看到过的场景，约莫是人行步道较窄，等车的人竟一字排开，队伍绵延了很长的距离。这样的情形我只在学校、火车站、银行这样显而易见需要排队的地方看得到，而公交车站，青岛是第一个，顿生好感。</p>
<p><img src="/img/qingdao/qingdao-48.jpg" alt="">    </p>
<h1 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h1><p>　　第二天一早，我便动身去海洋馆，不是极地世界，另一个，多是热带或者亚热带海洋生物。海洋馆的分布很有趣，一个大馆外加几个小馆，从小馆开始看，渐入佳境，最后是压轴的大馆。最开始结果却是最惊艳的，水母馆，看到了许多形形色色的水母，有的还能自己发光，美轮美奂，童话故事一般。</p>
<p><img src="/img/qingdao/qingdao-49.jpg" alt=""> </p>
<p><img src="/img/qingdao/qingdao-50.jpg" alt=""> </p>
<p><img src="/img/qingdao/qingdao-51.jpg" alt=""> </p>
<p><img src="/img/qingdao/qingdao-52.jpg" alt=""> </p>
<p>　　还有一种水母名字特别逗，一看就是吃货起的，煎蛋水母。别问我为啥加这个名字，自己看图，活脱脱一个煎蛋。</p>
<p><img src="/img/qingdao/qingdao-53.jpg" alt=""></p>
<p>　　从水母馆到别的馆要路过一片礁石，又没抵制住大海的诱惑，被勾引过去玩了一会儿。抓了两只小螃蟹，结果翻过来一看，蟹妈妈啊，赶紧扔回海里面。</p>
<p><img src="/img/qingdao/qingdao-54.jpg" alt="">    </p>
<p>　　下个馆是海洋生物馆，淡定的大海龟。别的就是些企鹅海豹什么的，我就不贴了。</p>
<p><img src="/img/qingdao/qingdao-55.jpg" alt=""></p>
<p>　　紧接着是标本馆，刺豚兄，你咋成标本了呢。都成标本了，咋还卖萌呢，眼睛辣么大辣么萌。(*^__^*)</p>
<p><img src="/img/qingdao/qingdao-56.jpg" alt=""></p>
<p>￼<br>　　走着走着，突然被一副漂亮的海藻标本吸引了过去。驻足，细看，这哪里是标本，分明就是一副画。大自然或许本就是一位肆意挥毫泼墨任性的画家，而装裱这幅画的工作人员兴许也对这美赞不绝口，不然怎会用宣纸来做底。</p>
<p><img src="/img/qingdao/qingdao-57.jpg" alt="">    </p>
<p>　　一个海螺的壳，依旧是美的不像话，学数学的我竟从中看出了若干个函数的曲线。数学，很美。</p>
<p><img src="/img/qingdao/qingdao-58.jpg" alt="">    </p>
<p>　　你看我发现了什么，中日枪乌贼的对比。工作人员也是够了，故意把两个放在一起，哈哈，干得漂亮。我们中国的就是又长又粗，额，好污，掩面。</p>
<p><img src="/img/qingdao/qingdao-59.jpg" alt=""></p>
<p>　　咦，这不是老家的土鳖么。啊不，好像是海鳖（鳌）？</p>
<p><img src="/img/qingdao/qingdao-60.jpg" alt="">    </p>
<p>　　海里啥都有，连个豆芽都有。</p>
<p><img src="/img/qingdao/qingdao-61.jpg" alt=""></p>
<p>　　这鱼感觉有点像被裹了面衣然后用油汆过一样，香脆可口。毒鮋，毒……</p>
<p><img src="/img/qingdao/qingdao-62.jpg" alt=""></p>
<p>￼<br>　　北海狗，南小鸟，啊不，南海狮。东啥？西又是啥？</p>
<p><img src="/img/qingdao/qingdao-63.jpg" alt=""></p>
<p><img src="/img/qingdao/qingdao-64.jpg" alt="">     </p>
<p>　　发现一只萌萌的野生小萝莉，哈。</p>
<p><img src="/img/qingdao/qingdao-65.jpg" alt=""></p>
<p>　　接着是很漂亮很长的海底隧道，值得一提的是，隧道里面有自动步梯，人站在上面缓缓移动。你需要做的是只有欣赏，那种鱼儿在四周游来游去的感觉实在太奇妙了，光顾着看了，没拍几张照片。</p>
<p><img src="/img/qingdao/qingdao-66.jpg" alt="">    </p>
<p>　　出了海底隧道，额，单身狗到哪儿都能被虐。/(ㄒoㄒ)/~~</p>
<p><img src="/img/qingdao/qingdao-67.jpg" alt=""></p>
<p>　　这是伪装的一条鱼，你能看出来它在哪儿吗？我盯着那些个小圆柱看了半天才发现自己是个逗逼。</p>
<p><img src="/img/qingdao/qingdao-68.jpg" alt=""></p>
<p>￼<br>　　有个地方特别好玩，可以把手指头伸进去，小鱼就会游过来亲你。其实是吃你手上的死皮，去死皮利器有木有。</p>
<p><img src="/img/qingdao/qingdao-69.jpg" alt="">    </p>
<p>　　看到一种很神奇的小雨，居然是透明的，内脏和骨骼看的一清二楚，不过好像没啥脏器么。</p>
<p><img src="/img/qingdao/qingdao-70.jpg" alt="">  </p>
<p>　　逛完后回旅馆休息，本打算下午去崂山，可是感觉有些远，再加上又睡过了，于是乎就没去。下午窝在旅馆里玩电脑，因为第二天一早还有赶飞机，所以早早就睡了。</p>
<h1 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h1><p>　　第二天一早五点半便爬起来，坐上之前叫好的专车，奔赴机场。别问我为什么买这么早的机票不多玩半天，把八点到达的机票以为是晚上八点的，你们别理我，哼。</p>
<p>　　踏上飞机的那一刻，我的青岛之旅便结束了。带走带不走的，全在这里了，满满的全都是快乐的回忆。有的人，每到一个地方旅游，不拍很多自己的照片、买几样纪念品就觉得好像没来过这个地方，其实不必如此，有这份回忆便足够了。我基本上很少拍自己，而有些人，基本上只拍自己，笑。</p>
<p>　　青岛几乎满足了我对大海的一切向往，我去过北海、海南，唯独青岛，大海、蓝天、沙滩、礁石、海鸥、军舰，样样不缺。　</p>
<p>　　这么温柔的地方，有机会，我带上恋人再去一次。然而，我是单身狗，这是一个悲伤的故事。/(ㄒoㄒ)/~~　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　青岛是一座无比温柔的城市，我很喜欢。&lt;/p&gt;
&lt;p&gt;　　前段时间写论文写得有些烦了，很想出去溜达溜达，恰好家人去青岛参加会议，我也屁颠屁颠跟过去蹭吃蹭喝蹭玩。&lt;br&gt;　　如果想找旅游计划的话，可以直接戳这里：&lt;a href=&quot;http://www.jerryfu.net
    
    </summary>
    
      <category term="琐事物语" scheme="http://jrhu05.github.io/categories/%E7%90%90%E4%BA%8B%E7%89%A9%E8%AF%AD/"/>
    
    
      <category term="游记" scheme="http://jrhu05.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WorksApplication机试题求解心得</title>
    <link href="http://jrhu05.github.io/post/worksApplication-character-recognition.html"/>
    <id>http://jrhu05.github.io/post/worksApplication-character-recognition.html</id>
    <published>2016-05-31T03:15:33.000Z</published>
    <updated>2016-05-31T03:29:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>　昨晚看完学校的晚会回实验室，发现几个同学在很激烈的讨论问题，然后听到了什么矩阵、特征向量。数学系出身的我一下子就被吸引住了，本着有好玩的就要凑个热闹的心态问了问，原来他们在讨论一道WorksApplication（什么公司？没听说，好像很小的样子）的机试题，好像已经讨论了蛮长时间，然后说用什么很高大上的01字典树（我打的对的吧？），感觉好牛逼好屌的样子，结果一看题目，嗨，什么嘛。</p>
<p>　　把题目扒下来给你们瞧瞧：</p>
<p>Character Recognition</p>
<p>Description</p>
<p>Character recognition is the conversion of images into text. For now we consider each character in the picture is a N*M matrix with only zeros and ones, and we need to recognize K characters. You are to write a program to find minimal number of pixels so that we can recognize each character.</p>
<p>For example, we have only two characters ‘T’ and ‘L’, and the matrix size is 3*3, we can think ‘T’ and ‘L’ are</p>
<p>111    　　　100</p>
<p>010    　　　100</p>
<p>010    　　　111</p>
<p>so we can recognize the character with only bottom-left pixel, the answer is 1.</p>
<p>Limits</p>
<p>•    Memory limit per test: 256 megabytes</p>
<p>•    Time limit per test: The faster the better</p>
<p>•    Input</p>
<p>•    The first line of input is three integers N, M, K (1 &lt;= N, M &lt;= 10, 2 &lt;= K &lt;= 6). Which represents the size of matrix and number of characters. Then is following K blocks, which represents the matrix. Notice that each block starts with a blank line and we guarantee that characters are different.</p>
<p>•    Output</p>
<p>•    You should output the minimum number of pixels, which is the answer.</p>
<p>•    Sample Test</p>
<p>•    input</p>
<p>•    2 3 2</p>
<p>•    </p>
<p>•    111</p>
<p>•    010</p>
<p>•    </p>
<p>•    100</p>
<p>•    100</p>
<p>•    output</p>
<p>•    1</p>
<p>　　说白了就是输入若干个同型01矩阵，然后寻找最少的点数来区分这若干个矩阵。我刚开始感觉有点意思，结果越分析越觉着出题目的人是智障，容我慢慢道来。</p>
<p>　　直接正面入手肯定是不行的，一个个组合即使输入矩阵数目不多那么组合起来也是很可怕的数目，穷举法什么的，最不优雅了。正面不行，咱们反其道而行，你不是找能用来区分的点么，我偏偏不找这些点，我找不能区分的点，我们装B一下称这种点为无用点（useless Point），那么什么样的点是不可用的呢？设想一下集合的交集，两个几个相交的部分一定是不能用来区分两个集合的，因为大家都是一样的嘛，推广一下，也就是说无用点即为所有输入矩阵中值一样的那些个点。剩下就好办了哇，排除掉这些一定不能用的无用点，剩下的点都可以用来当做区别点组的组员，后面2B的事情就来了，根据编码规则，要区别N个矩阵，那么最少需要log N（这里log以2为底，我不知道怎么写下标），那么我们只要判断可用点数目是否大于这个临界值不就行了么，如果大于那么输出log N向上取整的整数，如果小于，说明无法有足够的点来区分，咱就输出个0吧。关键，最最最2B的事情来了，小哥（让我帮忙做题目的同学的绰号）说输入的这些个矩阵一定是可以区分的，那照这样的话我直接输出那个log N向上取整的整数不就可以了么，2333。</p>
<p>　　关于怎么找出无用点我是这么设计的，设立一个N*M的矩阵（和输入矩阵同型），设该矩阵为NB（嗯，牛B矩阵），然后矩阵中每个元素是一个长度为2的int数组，设为a，a[0]的值表示该矩阵位不同输入矩阵中值为1的个数，a[1] 的值表示该矩阵位不同输入矩阵中值为0的个数，然后顺序扫描各个输入矩阵，分别判断每一位的值，相应的改变NB矩阵中对应的一维数组中的值。随后设立一个值为N*M的数，表示初始可用点数，接着遍历统计NB矩阵中各个位中的一维数组的两个位，只要有一个位的值和输入矩阵个数是一样的，即表明在这个位所有的输入矩阵的值是一样的（或0或1），然后这个点就是无用点，初始可用点数减去1。一轮线性扫描后就得出了可用点个数，然后判断一下就ok了。</p>
<p>　　我把思路告诉他之后，他说让我帮忙实现（喂喂，有这么厚颜无耻的么，笑），他说他只会py交易，c和java都不大会，然后题目只能用c/c++、java来提交，我没理他。然后他说“请你一顿饭，外加两鸡腿，还有饮料！帮不帮？”，我一听，有鸡腿还有饮料，“帮帮帮！”，然后花了一二十分钟编了出来，我很想直接syso一个log N向上取整的整数啊，可那样有点太二B了，还是老老实实写吧。</p>
<p>　　然后代码如下，因为输入较小，所以也没做优化，渣代码，且有注释强迫症，轻喷（提交一次通过，accepted）：</p>
<pre><code>package challenge;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class CharacterRecongnition {
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        ArrayList&lt;Object&gt; cubeList=new ArrayList&lt;&gt;();
        int row=0;
        int cloum=0;
        int cubeNumber;
        String temp=cin.nextLine();
        String[] tempString=temp.split(&quot; &quot;);
        int[] need={0,0,0};
        for (int i=0;i&lt;3;i++) {
            need[i]=Integer.valueOf(tempString[i]);
        }
        row=need[0];
        cloum=need[1];
        cubeNumber=need[2];
        //读入cube
        for(int i=0;i&lt;cubeNumber;i++){
            //跳过空行
            String noUse=cin.nextLine();
            int[][] tempCube=new int[row][cloum];
            for(int j=0;j&lt;row;j++){
                //读入一行
                String rowString=cin.nextLine();
                char[] c=rowString.toCharArray();
                int number=0;
                //System.out.println(c.length);
                 for(int m=0;m&lt;c.length;m++){
                        number =Integer.parseInt(String.valueOf(c[m]));
                        //System.out.println(number);
                    }
                for(int k=0;k&lt;cloum;k++){
                    tempCube[j][k]=number;
                }    
            }
            //System.out.println(Arrays.deepToString(tempCube));
            cubeList.add(tempCube);
        }
        System.out.println(findSmallestDiff(cubeList));
    }

    public static int findSmallestDiff(ArrayList&lt;Object&gt; cubeLis) {
        int cubeNumber=cubeLis.size();
        int[][] cube1=(int[][]) cubeLis.get(0);
        //列数
        int cloum=cube1[0].length;
        //行数
        int row=cube1.length;
        //构造新的牛逼矩阵
        Object[][] nb=new Object[row][cloum];
        //遍历同时初始化
        for(int i=0;i&lt;row;i++){
            for(int j=0;j&lt;cloum;j++){
                int[]mark={0,0};
                nb[i][j]=mark;
                }
            }

        //开始逐个处理矩阵
        for (Object cube : cubeLis) {
            int[][] tempCube=(int[][]) cube;
            for(int i=0;i&lt;row;i++){
                for(int j=0;j&lt;cloum;j++){
                    int[]mark=(int[]) nb[i][j];
                    if (tempCube[i][j]==1) {
                        mark[0]=mark[0]++;
                    }else{
                        mark[1]=mark[1]++;
                    }
                    //mark还原
                    nb[i][j]=mark;
                }
            }
        }
        //处理完毕开始判定
        int totalMarkPoint=row*cloum;
        for(int i=0;i&lt;row;i++){
            for(int j=0;j&lt;cloum;j++){
                    int[] tempMark=(int[]) nb[i][j];
                    if (tempMark[0]==cubeNumber||tempMark[1]==cubeNumber) {
                        totalMarkPoint--;
                    }
                }
            }
        int border=(int) Math.ceil(log(cubeNumber,2)); 
        if (totalMarkPoint&gt;border) {
            return border;
        }

        return 0;
    }

        static public double log(double value,double base) {
                    return Math.log(value) / Math.log(base);
                }
}
</code></pre><p>　　然后今天早上，出于好奇搜了一下，我的妈呀，日本的啊，福利据说不错哇，好像还能免费去日本旅游啊。关键，关键，起薪600w啊，日元也不少啊，折算过来35W多啊，一年顶我两三年啊！！！</p>
<p>　　他第二题说在网上找到类似的代码了，也过了，这样两道题目全部accept，进面试应该妥妥的了吧。</p>
<p>　　我怎么觉得我被他一个鸡腿打发了有点亏啊……</p>
<p>　　我也想去日本玩！我也想去Works Application！我也要拿600w，哼！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　昨晚看完学校的晚会回实验室，发现几个同学在很激烈的讨论问题，然后听到了什么矩阵、特征向量。数学系出身的我一下子就被吸引住了，本着有好玩的就要凑个热闹的心态问了问，原来他们在讨论一道WorksApplication（什么公司？没听说，好像很小的样子）的机试题，好像已经讨论了
    
    </summary>
    
      <category term="研究僧呀" scheme="http://jrhu05.github.io/categories/%E7%A0%94%E7%A9%B6%E5%83%A7%E5%91%80/"/>
    
    
      <category term="矩阵区分,算法,worksapplication机试" scheme="http://jrhu05.github.io/tags/%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%88%86-%E7%AE%97%E6%B3%95-worksapplication%E6%9C%BA%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>杭州</title>
    <link href="http://jrhu05.github.io/post/hangchou.html"/>
    <id>http://jrhu05.github.io/post/hangchou.html</id>
    <published>2016-05-23T13:22:11.000Z</published>
    <updated>2016-05-23T14:18:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　杭州挺不错的，这是我短暂杭州之行后的感受。</p>
<p>　　前几天我一朋友要去杭州办点事情，本打算当天去当天回。我觉着这样太累了，于是半开玩笑的说若是在那里住一晚的话我也跟着去蹭玩，没想到他说好啊，然后我就一起去了，小论文都没写完，于是把笔记本也带上了。    </p>
<p>　　他上午十点要和人谈事情，所以就早些先出发，我定了晚一点的车，睡得差不多了优哉游哉往高铁站赶。说来也奇怪，南京到杭州的动车与高铁差不多时间都是一个半小时，结果票价差了近一半，不过动车班次少的可怜，穷学生的我挑了半天才找到一张动车票。   </p>
<p>　　到杭州东站后，进入了出站通道，一下就被震住了，杭州真有钱啊，高铁站居然修了和机场航站楼一样的横向代步电梯。如图1。然后过街天桥上下居然全是自动扶梯有木有，好洋气啊。嗯，我就一土鳖。<br>　　<br><img src="/img/hangchou/1.jpeg" alt=""></p>
<center>图1 横向电梯</center>

<p>　　额，论文写多了，不自觉就加了个图1……下面的不加了</p>
<p>　　然后便坐地铁往住的地方赶，下地铁后看到，道路很窄，仅是四车道，且车速缓慢，后来和在杭州的实习的同学聊天，他也抱怨杭州的公交是蜗牛速度，所以干脆买了个自行车直接从租房子的地方骑到实习地点。去旅店的路上，杭州另一个特质给我留下了深刻的印象，特别有文化味道，很多建筑，看着不起眼，然后立了个石碑，多少年前建的，包括较为繁华的西湖附近，顿生好感。例如下面的基督教会，很高大上有木有。<br>　　<br><img src="/img/hangchou/2.jpeg" alt=""></p>
<p>　　到旅店后发现很一般，果然图片宣传什么的谁信谁傻缺，刚开始还为好几百的住宿费觉得不公平，可后来吃了一顿午饭后觉得哇这价格还不错。一顿面条几十块什么的，我才不会告诉你呢。由于就住在西湖边上，所以我本打算不等他直接去西湖溜达溜达，结果后来来电话说快结束了，等等好了，顺便翻翻随身带来的一本小书，“我不喜欢这世界，我只喜欢你”，另一个朋友强烈推荐的，我还抱怨给我一个单身狗推荐这种书干什么，结果他说你不是EQ低么，补补，我：你才EQ低，你全家EQ都低。本以为会很矫情，结果意外的好看，这书以后单独再说吧。看了会儿他回来了，我们便去吃饭，面条，贵贵贵，吃完后我提议直接去西湖，他说什么早上起早了要补个觉，好吧，补觉。结果回到旅店后他歪在床上看起了手机，然后觉得有些乏了，倒是我睡了一会儿。精神后直奔西湖，嗯，某逗逼的手机导航错了害的绕路什么的我就不说了。对了，补一张我们住的狗窝。</p>
<p><img src="/img/hangchou/3.jpeg" alt=""></p>
<p>　　早就对欲把西湖比西子一类的诗句描绘出的意境心驰神往，结果到了西湖后略略失望，从没见有人告诉我西子会略黄啊，是真黄，水面黄黄的，还没有我们在苏州经常逛的独墅湖干净呢，照理说湖泊越大应该自净能力越大，越干净才对。然后我们就俗套的在西湖的大牌子哪里拍了照，嗯，逗逼怎么拍都是这么逗逼。<br>￼</p>
<p><img src="/img/hangchou/4.jpeg" alt=""></p>
<p>　　然后这就是西湖的水，你们感受一下，阴天，光线不大好，将就看着吧。</p>
<p><img src="/img/hangchou/5.jpeg" alt=""></p>
<p>　　然后还有这种小船，晃晃悠悠的，感觉风大点就会翻似得，而且没有救生衣，他倒是没事会狗刨，我估计可就得GG了。我们一看不安全就没坐，主要是太黑，要好几十，到岛上还得回来，来回要几百块，太坑爹了。这就是那小船，我绝对是为了拍船，而不是拍妹子，而且还糊了。<br>　　<br><img src="/img/hangchou/6.jpeg" alt="">
　　</p>
<p>　　不过西湖观景大道两旁的树木和绿色植被倒是挺漂亮的，漫步其中，边走边看风景，吹吹牛，也很是自在。观景道另一侧有一个被隔开的小一点的湖，我把它叫做小西湖，别和我提什么扬州的瘦西湖，简直太坑人了。那个小西湖水倒是很清，明明两者是想通的。途中发现了一颗漂亮的大树，叫不出名来。</p>
<p><img src="/img/hangchou/7.jpeg" alt=""></p>
<p>　　途中我们还发现了两只小松鼠，及其灵活，跳上跳下的，而且一点也不怕人，第一次看见活的小松鼠有木有，很鸡冻，感觉好可爱啊。</p>
<p><img src="/img/hangchou/8.jpeg" alt=""></p>
<p>　　我们后来走着走着，天色渐晚，然后发现一个地方人头攒动，本着有热闹必看的原则，我们赶紧跑过去，结果一打听说是有光影喷泉，好家伙，免费的，不看白不看。感觉很棒，效果不错，光顾着录像了，也没拍几张照片，好位置是需要买几瓶啤酒消费才能去的，我们离得比较远，被挡住了不少，挑了一张自认为还不错的，渣像素，轻喷，单反什么的买不起。</p>
<p><img src="/img/hangchou/9.jpeg" alt=""></p>
<p>　　路上看到一座矮矮的小塔，我说那是不是雷峰塔，他回应该是的吧，就那个压许仙的那个。我立马无语了，雷峰塔压许仙啊！许仙啊！小伙子你这是从什么地方穿越而来的啊，你怎么不说压的是法海啊。解释了半天，然后我们就莫名其妙的开始聊起来新白娘子传奇，然后居然唱起了那么百年修得同船渡……话说那雷峰塔景区居然还要几十块的门票，照例是研究僧不是人不给半价，所以我们也就没进去，一个破塔什么的外面看看就得了。    </p>
<p>　　最后一看手机，我们居然走了3W步，断断续续走了十几公里，前几天刚走了五十公里脚才缓过来，这又疼起来了。    </p>
<p>　　晚上我们约了一个在杭州实习的老同学一起出来聚聚，主要是想蹭顿饭。大家都是穷学生，想来想去，还是决定去外婆家，实惠。本想去离西湖近的那家，到那家发现人巨多，然后店小二忽悠我们说XXX那家店是总店，打的过去也就十几分钟，不用等，我们一听，好吧，去那家吧。结果到那所谓的总店一看，嚯，人也不少，拿号排队等了半天，到我们时候都给饿的够呛，本想来个西湖醋鱼什么的，结果说便宜的草鱼现在不做了，说刺多怕客人卡着，额，这么贴心，确定不是因为草鱼不赚钱才不做的？然后点了些别的，边吃边扯淡，青豆泥、麻婆豆腐什么的，最喜欢了，又便宜有好吃，可惜麻婆豆腐卖完了。他们聊，我吃。</p>
<p><img src="/img/hangchou/10.jpeg" alt=""></p>
<p>￼<br>　　吃完后因为实习的哥们回住处还要好几个小时，我们也就没多留，各回各家各找各妈。半夜下起瓢泼大雨，他被吵醒了，起来撒个尿，结果我没被雨吵醒，倒是被他给折腾醒了，2333。第二天一早，雨还在下，本来计划去浙大转悠转悠的，结果因为雨太大只得作罢，其实吃完早餐往地铁站赶得时候雨下的已经很小了，我是挺想去的，他以前去过不大想去，然后我也不好强求，下次再去吧。   </p>
<p>　　吃早饭的时候，他先吃完，对着窗外狂拍，我问，你对着一个变压器拍什么玩意？他说拍一下杭州的雨发个说说装文艺，我问，你准备写什么。他说，杭州的雨，淅淅沥沥。我歪头略微一想，这样写吧，窗外的雨，从杭州下到了南京。装13什么的，还是我略胜一筹，笑。</p>
<p><img src="/img/hangchou/11.jpeg" alt=""></p>
<p>　　杭州，不错，若有机会定会再去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　杭州挺不错的，这是我短暂杭州之行后的感受。&lt;/p&gt;
&lt;p&gt;　　前几天我一朋友要去杭州办点事情，本打算当天去当天回。我觉着这样太累了，于是半开玩笑的说若是在那里住一晚的话我也跟着去蹭玩，没想到他说好啊，然后我就一起去了，小论文都没写完，于是把笔记本也带上了。    &lt;/p
    
    </summary>
    
      <category term="琐事物语" scheme="http://jrhu05.github.io/categories/%E7%90%90%E4%BA%8B%E7%89%A9%E8%AF%AD/"/>
    
    
      <category term="游记" scheme="http://jrhu05.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>友人A</title>
    <link href="http://jrhu05.github.io/post/friendA.html"/>
    <id>http://jrhu05.github.io/post/friendA.html</id>
    <published>2016-05-23T13:22:11.000Z</published>
    <updated>2016-05-23T14:20:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　我们这一辈子或许会遇到很多的人，有的人注定是匆匆过客，而有的人则会在你的心中留下深深的印记。</p>
<p>　　好久不曾联系，偶然间通了音信，居然熟络的一如当年，时间未曾疏远了些许。“喂，XXX吗？我是XXX。”，“哦，我知道，我X你大爷。”，男人与男人之间，就是这么简单随意。</p>
<p>　　我和他初三那会儿是同班，很不凑巧的是同桌。当时我们班主任比较开放，排位置的时候让我们自己选座位，当然成绩好的先选，已选的位子标记一下。轮到我的时候，从小就是个选择困难症患者，墨迹了半天，结果老师不耐烦了，说：“好啦，我来帮你选。”，结果后来才知道老班把最后剩下的一个没人要的位子给我了，哭。然后公布座位表的那天，我一看座位表头都大了，居然是第一排紧贴着老师讲桌那个座位，完蛋了，没法上课开小差什么的了。然后一看同桌，A君，知道有这号人存在，不了解，罢罢，算我倒霉。我坐下后，还在纠结第一排的事情，结果他瞟了我一眼，“我是XXX，不喜欢和笨的人来往，别烦我。”，我瞬间给噎的不知道该怎么回，我看起来有那么笨？等我想了半天终于想好了该怎么反击的时候，好家伙，他居然开始呼起来了，我去，同桌是个极品。</p>
<p>　　然后，就是平平淡淡的日常，刚开始他倒是挺老实的，虽不认真听，但也就走走神画画小人什么的。一个星期后狐狸尾巴终于露出来了，英语课，书一架，直接开始看小说书了，你当老师瞎啊，就在眼皮子底下怎么可能看不到，我心想有好戏看了，结果老师居然不闻不问。他一看老师不管，更嚣张，挡也不档了，直接拿到书桌上开看，还边看边写写画画，不知道的人可能还以为这小子学习好认真啊。我心想，这也太不公平了，成绩好就能为非作歹么，无奈我是个半吊子，学来学去成绩也不见起色。</p>
<p>　　他脑袋瓜子确实聪明，据他自己吹嘘IQ125，我心想好嘛翻倍正好250，很符合你的个性。他那时候成绩从来没掉出过前五，但是你要说是也像那些女生那样认认真真学取得这样的成绩也就算了，关键是他毛都没学啊，上课不听，下课不做作业，考前不复习，没事还和老师顶一下，天天耷拉个拖鞋，有次考试居然连笔都没带，还是我借给他的。这种存在简直就是啪啪啪的打我们这些个吭哧吭哧学的笨蛋的脸啊，当时小心眼各种羡慕嫉妒恨。</p>
<p>　　他从那次看小说之后越发嚣张，不知道从哪里搞来了一个步步高电子词典，下了一个叫什么三国霸业的游戏，玩的不亦乐乎。后来又弄了套卡牌，自己和自己打着玩，我都看呆掉了，真乃神人耶。他对我的态度也从最初的爱理不理慢慢的发生转变，我请教他问题他也会大笔一挥提点一番，我每次请教他问题都会有一种莫名的屈辱感，哼，聪明就了不起啊，有时候他画的实在太简洁我就不得不厚脸皮再多问问，结果他就用一种同情看智障的眼光看着我，看得我也不好意思再问，整的一肚子火只好趁其不在猛踹几下他凳子桌子什么的。</p>
<p>　　后来可能他玩的可能实在太腻歪了，一天午休时候，他玩他的，我睡我的，突然猛的给了我一肘子，我差点没蹦起来。正准备发作，他对我甩了甩电子词典，“要玩吗？”，玩你大爷啊，老子气得要死，忍着没骂出去。然后我又趴桌子上睡了，结果好家伙，又是一肘子，得得得，大哥，你牛x还不行吗，我玩，我玩。然后就接过来开始玩，由于之前从来没玩过，所以什么也不懂，然后他就给我介绍起来，什么要屯兵、和谁联合打谁、打曹操一打一个准，因为曹操粮草带的总不多（设计这游戏的是弱智么）、谁该招降招降该剁了剁了，还给我总结了一套发展不如去抢的理论，然后还时不时的骂一句怎么这么笨，这都能打不过。然后我就给他带坑里去了，上课也开始偷偷摸摸看小说玩游戏什么的，每天都过着偷鸡摸狗良心被谴责的日子，后来和他聊这事情，他大大咧咧的和我说，没事，你以前就是因为学的太多了，脑子给学不灵活了，我这带你打通脑部筋脉血络，你放心，成绩一定不会下降，说不定还能上升呢。年少无知的我，居然信了，信了，然后每天也跟他一样吊儿郎当的，由于是初三毕业班，大家都很认真，就我们俩异类，然后就被戏称为“混子二人组”，他那是被人戏称，我那是实打实的混日子。结果到期中考试后，我哭了。</p>
<p>　　他还是前五，我就惨了，直接快倒数了，老班直接找到我说“XXX，你别和XXX学啊，他那么聪明，你那么笨，blablabla”，老师这么一说我哭的更凶了。老班安慰半天，完了跟我嘱咐，以后上课认真听讲，别看小人书玩游戏什么的，还有时间加把劲可以的。我赶紧谢过。回班后他一看我这惨样，忍着笑说，你以后别玩我的游戏机和看我的书了，认真学习吧笨蛋。</p>
<p>　　自那以后我是没再看小说书和玩游戏，不过和他聊天吹牛什么的还是有的，我也了解到了他的人生观价值观以及今后的追求。对于一个人生观、价值观尚在形成，人生目标什么的完全没有的小白来说，遇到一个这么三观正、有理想的小青年，简直崇拜的不要不要的。他那种散漫、闲适的生活方式与追求也深刻影响到了我后来的种种选择，称之为导师不为过。</p>
<p>　　他也把很多东西传染给了我，火影是他带我入坑的，虽然他现在已经不看了。在此之前我也就知道一个百变小樱什么的，可以说是他带我踏入二次元。科幻小说也是他带我看的，朴树的歌是他带我听的。我那时候从我爸那儿得到一个MP3，那时候可以说是很时髦的，好家伙，给他知道后直接霸占了，我都得找他借，不过也因此听到了不少好歌，当年学校门前小商铺下载歌曲一首都得好几块，我穷的根本下不起歌，人家土豪，一来就是：老板，下满！</p>
<p>　　我们那时候很巧的是宿舍也在一起，床头对床头，我有时候嫌他脚臭会睡到另一头。记得中考那夜，我失眠了，小小年纪慌得不成样子，不知怎么的居然哭了起来，怕打扰别人休息只能抽抽噎噎，估计他给吵醒了，小声问明白后，不停的安慰我，不要紧什么的，后来我居然就这么迷迷糊糊睡着了。第二天我是精神不错，他就不行了，困困蔫蔫的，现在想来也很是愧疚。</p>
<p>　　后来中考结束，我很是意外的考取了本校的正取（免学杂费，私立学校当时学费就得好多），但是还是很矫情的在家人面前哭了一鼻子，以示自己没做到最好，然后背地里偷着乐。他好像没怎么考好，不知是不是因为那晚没睡好的缘故，后来他选择去了公家的县立中学，我知道后互道了一声珍重再见，却不知这一别竟是近十年的鸿沟。虽在同一个小城，可高中后课务繁忙，而且两校之间互有门禁，也就没再联系。高中毕业后，去了不同的大学，更没有联系。大学毕业后他南下闯荡，我读研，距离越来越远。</p>
<p>　　虽过去了近十年，可那些事情、那些话却未曾淡忘了半分。</p>
<p>　　前些天联系，我半开玩笑的说要去找他蹭饭，这顿饭我蹭定了什么的，然后他爽快的说，行，没问题。</p>
<p>　　得此良友，足矣。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　我们这一辈子或许会遇到很多的人，有的人注定是匆匆过客，而有的人则会在你的心中留下深深的印记。&lt;/p&gt;
&lt;p&gt;　　好久不曾联系，偶然间通了音信，居然熟络的一如当年，时间未曾疏远了些许。“喂，XXX吗？我是XXX。”，“哦，我知道，我X你大爷。”，男人与男人之间，就是这么简
    
    </summary>
    
      <category term="琐事物语" scheme="http://jrhu05.github.io/categories/%E7%90%90%E4%BA%8B%E7%89%A9%E8%AF%AD/"/>
    
    
      <category term="朋友" scheme="http://jrhu05.github.io/tags/%E6%9C%8B%E5%8F%8B/"/>
    
  </entry>
  
  <entry>
    <title>老师</title>
    <link href="http://jrhu05.github.io/post/teacher.html"/>
    <id>http://jrhu05.github.io/post/teacher.html</id>
    <published>2016-05-23T13:13:11.000Z</published>
    <updated>2016-05-23T13:18:27.000Z</updated>
    
    <content type="html"><![CDATA[<p> 　　我很怕老师。</p>
<p>　　那年，我初二，13岁，英语课代表，英语老师是班主任。那时候活泼好动爱表现，上课时候老是会插嘴，他对我颇有微词。一天突然把我叫到办公室，“给我站好”，我闻到他一身酒气，赶紧乖乖站好。啪的一声突然给了我一巴掌，很突然且力道很大，我只觉得半边脸火辣辣的，耳朵也嗡嗡响。“知道为什么打你吗？”，我还没从第一巴掌中反应过来只好说道“不知道”，啪又是一巴掌，当然，换了半边脸。“有人说看见你交试卷的时候乱翻我抽屉，你翻了吗？”“我没有”，啪又是一巴掌，“我真没有！”，啪又是一巴掌，我不敢再说了，之后他blabla一堆，我刚准备庆幸不打我了，他突然没头没脑的问“上课为什么老是插嘴？”，这次我学乖了，没吱声，啪又是一巴掌，怎么不回答还打我啊。我向他办公桌对面的另一个女老师看了看，希望能寻求帮助，她是我初一的英语启蒙老师，会喜欢上英语也是因为她，温柔善良而且漂亮，她当时也挺喜欢我的，让我当了英语课代表，兴许是我们学校体罚蔚然成风，她熟视无睹，我人生头一回体会到了什么是绝望与无助，直到最后她也没说一句话，似乎这事与她一点儿关系也没有。</p>
<p>　　我心里觉得很委屈，于是不争气的哭了，他一见我哭了更来气，打的也更狠，打的我连哭都不敢只能一抽抽的哽咽。他断断续续边训斥边抽了一会儿，也许是有些累了，想来个收尾，猛地给了我一耳光，比前面的都要重，我没站稳晃了几下，我本身鼻子就容易出血，鼻血呼的就出来了，也不敢用手擦，血流过嘴巴下巴，一滴滴的滴到白色大理石地板上。他一看都这样了，赶紧说滚吧。我一听如释重负，赶紧飞的逃了出去，到WC洗了半天，怎么也止不住，刚好赶上下课，我们班有几个也来方便，我把头压得低低的，看都不敢看他们，顺道也让出了水池。没办法，一直止不住，怕自己就这么挂了，于是去医务室找医生，校医一看，“你这是怎么了？怎么流的这么厉害？”，“不小心摔的”，他看了看我的脸，没再说什么。最后足足用了三大包药棉才止住。</p>
<p>　　从那以后，对所有的老师，不论多么和蔼可亲，总是会忌惮三分，有意会拉开距离。也莫名的，对喝醉酒的男人多了几分恐惧。同时下定决心，这辈子绝不会做老师。</p>
<p>　　以后若有机会回母校看看，且他还在致远任教的话，我一定会请他出来吃顿饭，然后告诉他，以后再不能这么对待一个孩子。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 　　我很怕老师。&lt;/p&gt;
&lt;p&gt;　　那年，我初二，13岁，英语课代表，英语老师是班主任。那时候活泼好动爱表现，上课时候老是会插嘴，他对我颇有微词。一天突然把我叫到办公室，“给我站好”，我闻到他一身酒气，赶紧乖乖站好。啪的一声突然给了我一巴掌，很突然且力道很大，我只觉得半边
    
    </summary>
    
      <category term="琐事物语" scheme="http://jrhu05.github.io/categories/%E7%90%90%E4%BA%8B%E7%89%A9%E8%AF%AD/"/>
    
    
      <category term="老师" scheme="http://jrhu05.github.io/tags/%E8%80%81%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>我与她</title>
    <link href="http://jrhu05.github.io/post/her-with-me.html"/>
    <id>http://jrhu05.github.io/post/her-with-me.html</id>
    <published>2016-04-30T13:06:11.000Z</published>
    <updated>2016-08-28T04:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　晚上回到学校，星期天的缘故很是空闲，不知不觉又想起她了，又是一阵难过，终究还是放不下啊。</p>
<p>　　恨她吗？恨。爱她吗？爱。</p>
<p>　　这些文字注定是矫情、无病呻吟、矫揉造作的，不习惯的这种文风的可以叉掉了，余下的权当是看小说吧，图个乐呵，听听我的苦逼故事。</p>
<p>　　我知道这些东西她是铁定看不到了，为什么我就不说了，所以写出来也没有什么忌惮。</p>
<p>　　有些话是决绝不知道该对谁说的，家人、朋友都不行，但憋着又极其难受，索性一股脑的全写出来好了，爱谁看谁看，如人饮水，冷暖自知。</p>
<p>　　我脑海里对她的第一个记忆是讨厌，大一那会儿我还是个半吊子班长，她属于特别跳的那种，老是给我折腾事。有次去聚餐吃完了她居然跑过来指责我说肉少了，净是喝汤，班长怎么当的blablabla，我当时就无语了，大小姐，每人才35块钱啊，你当是满汉全席啊。于是她给我留下的影响就是死能做，这小丫头怎么这样子。俗话说三个女人一台戏，我们班当时大一接近一半还多的都是女生，好家伙，她们还搞起了拉帮结派小集团，各种尔虞我诈勾心斗角，整的跟个后宫大戏似的，班主任都给搞得焦头烂额。我那时候也不知道该怎么办索性不管了。由于平时都和团支书一起工作，本身就很熟悉，再者怎么也不能闹得团支书班长关系不好，这样班级吃枣药丸，这道理我还是懂的，所以自然的就给拉到了团支书一派。斗争吗，总归有输赢，她为首的那一派输了，结果她们那一帮子人也给整的惨兮兮的，我也是后来听她说的，详细不表。</p>
<p>　　再后来就跳到了大二下学期，我们学校有个交流生制度，大三选派一部分到A大交流学习，我们班有两个名额。我是在学校呆了两年有些腻歪了所以想换个环境出去玩玩，然后就提交了申请，正好六级分数又够，又跑去和老班聊了聊，然后就拿到了名额。她也报名了，据她自己讲是因为在学校待着憋屈，大二一整年都是白天一整天要么上课要么泡图书馆晚上回宿舍睡个觉，绝不在宿舍多呆，为什么我就不说了。然后班主任也知道这个情况，所以她拿到了另一个名额，我一知道这个消息头都大了，怎么是她啊。她倒好，直接来套近乎什么到新学校要互相帮助什么的，我随口应了下来。</p>
<p>　　然后就是去A大的大三生活，一切都在这里了。刚到A大我就把全校给摸了个透，哪里有洗手间什么的都一清二楚，她就不行了，找不到教学楼，没办法上课只能带着，谁叫是同学呢不管她有点于心不忍。然后我们就是喜闻乐见的上课路上一起，上课坐一起，吃饭一起。我也没多想什么，班里的新同学很是好奇的问我们，你们是情侣吗，我赶紧解释说不是，生怕闹误会，她也没说什么。就这样日子一天天过去了，我每天还是早上等她下来一起，即使在我和富贵他们混熟了以后。渐渐的从当初的一言不发开始有了交流，聊些有的没的，她特别喜欢玩，总说出去玩看电影什么的，我当时还是臭屌丝直男癌一个，一万个不愿意，老范倒是乐意，但总是要接一句你请客我就去，然后她就不吱声了。好不容易磨了一次，大家一起出去看电影，当然AA制，说出来不怕笑话，那是我第一次去电影院，很是兴奋，然后买了一堆吃的，就为这还被鄙视了一番。也是第一次和女生一起看电影，还就做我旁边，整场电影整个人都斯巴达了，现在想来，当时还是太嫩。有了第一次就自然还会有下一次，然后就是各种出去吃吃喝喝鬼混，有时我请有时她。逐渐的，由最初的讨厌变成了她人还好嘛，没那么挫。渐渐的我对她的了解也越来越多，喜欢什么，讨厌什么，生日什么时候，星座，血型，然后我也给她渐渐的带沟里面去了，也开始喜欢吃栗子、排骨，开始穿牛仔裤，会因为她说我QQ头像上线和没上线没区别果断的换掉，她的电话短信QQ会秒回，然后安慰自己这是礼节。</p>
<p>　　一天我和她一起去食堂吃饭，她还是照旧冬瓜排骨，我打了一份红烧肉，她盯着我盘子里的肉直流口水，完了还不忘加上一句好想吃肉啊。我没理她，心想想吃自己去打去呀，然后看她那可怜样又不好意思不给，推推盘子，你吃点吧，也就客气一下。结果好家伙，她居然二话不说自顾自的吃起来，片刻所剩无几，我赶紧护过盘子，大小姐，你好说给我留点啊。话虽如此，心里却是暖暖的，那一天也都在轻飘飘中度过。 </p>
<p>　　最重要的一点，她渐渐的改变了我的心。我之前是一个将自己内心层层包裹以刺示人，动不动就说一些很绝情的话的人，还自以为很酷。你如何叫一个在三天两头不是吵架就是打的环境中成长的孩子温柔的对待这个世界？我父母总是习惯性的用最粗暴方式对待这个世界，其实也怨不得他们，我父亲艰辛的奋斗史，我母亲充满血和泪的成长历程，这不由得使得他们对待世界的字典里存不下温柔二字。自然地，我也继承了一点。不过遇到她后，开始改变，她会指出我做的不到的地方，虽然有些尖锐，告诉我该怎么做。一点点的，我居然学会了如何去温柔的对待一个人，起码我觉得是。也渐渐的养成了一些小习惯，一起出去玩公路上会下意识的让她走里侧，过马路也会挡一下，递饮料会默默的拧开，偶尔给她带带饭多加点肉什么的，和她在一起永远不会自顾自的玩手机，出门前会习惯性的抽几张纸装在身上以备她不时之需，她从来不带纸巾，每次都找我要，要不到还叽叽歪歪数落我一通，自然而然就养成了这个习惯，直至今日。</p>
<p>　　她缺点其实很多的，比如我不止一次从她口中听到她把他整个宿舍的人都数落一遍，然后又把班上的哪个女生说一遍，听得我很是腻歪。再比如她经常会向外界辐射负能量，耷拉个驴脸，跟她讲话也是没好气。别的就不说了。</p>
<p>　　渐渐的，我觉察到了自己的心意，也开始有意无意的做一些事情。然后她似乎也察觉了，有一天她突然对我讲，又谁谁谁搭讪她了，然后自然的对我讲让我这样跟她一起就不会有人骚扰她了，又说什么让我当她的骑士。嗯，我都懂的，你的意思我很明白的，我也不好多说什么，装装傻，应了下来。结果她以为我没听明白，隔了几天又对我说，咱们俩不合适什么的blablabla一大堆，我脑袋都给她吵大了，我又不是驴木脑袋岂会不懂，只得浅浅嗯一声。然后我就很自觉的后退了几步，如旧。</p>
<p>　　后来得知她有男朋友，我就更注意自己的分寸。我们还是一起上课，一起吃饭，一起打游戏，一起泡图书馆，只是我知道有一条红线在我和她之间，我不敢越雷池半步。当时想着，就这样静静的看着她就够了，所以依旧会履行自己和她那个可笑的骑士约定，护着她，也不图什么回报，喜欢就好。</p>
<p>　　后来开始准备考研，她开始打算报B大，后来在我的建议下改了C大，后来果真考上了。然后就是一起报了考研班，还是照旧的一起去上考研课，图书馆自习。很快大三便结束了。</p>
<p>　　大四我们回到了本校，大家都开始各忙各的，为了防止别人说闲话除了一起去图书馆占座外，吃饭自是不能一起了，我和我们宿舍的基友，她和她的闺蜜一起，如有偶遇相视一笑。于是乎，早上我占好位子发个短信给她，她睡足了也就会过来，偶尔讨论一下问题什么的。那时候我忙于准备考研的事情，家父也是一天三个电话告诫我生怕我谈恋爱影响学习，所以也就压下了所有的念头。</p>
<p>　　后来就是考研结束准备复试，由于复试没什么的要紧的，我也就没去占座，随便找个图书馆的外围位子，优哉游哉。复试完了后论文答辩结束，很快迎来了毕业，老套的毕业聚餐。我可能喝的稍微有点多了，居然提一瓶啤酒就去找她，她看了我半天，我愣是啥也没说出来，最后挤出几个字，祝你幸福，然后猛灌，心里难过没忍住就哭出来了。她一见这状况，淡淡的说了句，我很幸福，然后不知道从哪弄来一瓶啤酒也开始吹起来，也哭得稀里哗啦，我至今也不懂得她这眼泪的含义。从那天以后我们一句话都没有再说过。</p>
<p>　　说实话我自己也不明白我到底喜欢她哪里，论长相吧也就那样，身材吧该凸不凸该凹不凹，而且瘦的要死，我曾经YY她要是生孩子一定得吃胖一点，要不太危险了，此外大小姐脾气还很臭，动不动就尥蹶子。我想她看我也应该是差不多的吧，浑身毛病。可不知为什么，就是喜欢她。她给我的感觉就如同那首river flows in you，安静优雅而又绵长，如水一般，静静流淌，那首也是我最喜欢的钢琴曲。</p>
<p>　　平时闲着没事就喜欢翻翻她的空间，说说一条条看下来，特别关注，所以有什么新消息第一时间都会知道，我也只是看看，从不评论。研一的时候了解到她失恋了，看她伤心那样心都快化了，我就想不通那沉迷游戏的渣男有什么值得她迷恋的。当时想着直接跑到她实习的地方去看看她，犹豫来犹豫去最后不了了之，生怕弄巧成拙朋友都做不成。就这样看着她的生活也挺好。</p>
<p>　　事情从上个学期开始一发不可收拾，遇到人生中一重大波折，生病了，需要吃一种药，药物的副作用是会使人处于一种类似半醉状态，大致就是自信心爆棚，控制力减低。结果就忍不住了，明知道踏过那条红线可能是万丈深渊却也莫名的有了勇气去赌那渺茫的机会，许不了你荣华富贵，但定能保你衣食无忧，我不要做什么狗屁骑士，我要做王子，我要追求自己的幸福，一定要将自己的心意传达到。结果是给她打了通电话，好几个小时，把前前后后都说了，也表明了自己态度，她一直安安静静的听，我又把她男友给骂了一顿，错上加错。然后她说容她考虑考虑，我说好。结果几天后想看看她空间，那个唯一的分组却空了，我有些慌了，赶紧打电话，对方正在通话中。最坏的结果。我当时就想，我和她就像蓝天上飞机划过留下的两条白线，今后永无交集。 </p>
<p>　　我喜欢的好辛苦啊。 </p>
<p>　　突然想到了一个人，研一我们实验室的，喜欢同一个实验室的某个女孩很久了。又是送花又是买蛋糕的，可是那妹子对她一点感觉也没有。有次和那个男生一起去吃饭，他突然叹了口气，我问怎么了，他说苦啊。嗯，我懂的，苦啊。也不知道该如何回应，只好缄默。吃饭时候他问我，追一个人很久那人却不回应该怎么办，我这个单纯的人什么时候成了情感大师了，看来他确实够憋屈的。我只能对他说，换一个人吧。后来他们一起到D市的某个公司实习，我嬉皮笑脸的同他说，看来你要有机会了，结果他苦笑一番，也没说什么，无话。</p>
<p>　　伤口暴露在阳光下应该会好的更快些，希望时间能冲淡这些，或者遇到下一个对的人。现在能做的唯有努力提高自身素质，培养自己的EQ，耐心的等待。</p>
<p>　　被上学期那次波折弄怕了，那些宏大的东西不再奢求，现在的想法很简单，择一城，遇一人，终老。</p>
<p>　　我想好了，给自己一个约定，给未来的那个她也给自己八年的时间，三十之前不相亲，若而立还遇不到那个她，那么再许她十年，开始相亲，只要有提必定去看，四十若还无，便死了这条心。</p>
<p>　　</p><p><embed width="1" height="1" src="http://www.xiami.com/widget/61405_3480577,_1_1_FF8719_494949_1/multiPlayer.swf" type="application/x-shockwave-flash" wmode="transparent" allowscriptaccess="never"></p><p></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　晚上回到学校，星期天的缘故很是空闲，不知不觉又想起她了，又是一阵难过，终究还是放不下啊。&lt;/p&gt;
&lt;p&gt;　　恨她吗？恨。爱她吗？爱。&lt;/p&gt;
&lt;p&gt;　　这些文字注定是矫情、无病呻吟、矫揉造作的，不习惯的这种文风的可以叉掉了，余下的权当是看小说吧，图个乐呵，听听我的苦逼故
    
    </summary>
    
      <category term="琐事物语" scheme="http://jrhu05.github.io/categories/%E7%90%90%E4%BA%8B%E7%89%A9%E8%AF%AD/"/>
    
    
      <category term="关于爱情" scheme="http://jrhu05.github.io/tags/%E5%85%B3%E4%BA%8E%E7%88%B1%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>关于花钱的一些小小想法</title>
    <link href="http://jrhu05.github.io/post/about-money.html"/>
    <id>http://jrhu05.github.io/post/about-money.html</id>
    <published>2016-04-29T16:02:39.000Z</published>
    <updated>2016-04-29T16:16:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　想通一些事情后小日子过得很是滋润，以前一直过得很苦逼，其实也不是缺钱，除了大二之前（那时候是真穷），就是舍不得花钱，一来是从小穷日子过惯了之前家里确实没钱又有一个奉行穷养的老爸穷上加穷，二来是即使后来家境稍好我爸每次给我打钱都会旁敲侧击的提醒我“十八岁了，该独立了”，搞得我总有一种负罪感，总想着能少用就少用，都从衣食住行上面省，省出来的钱又舍不得买自己想要的东西，结果稀里糊涂就被骗出来成了下个学期的学费。</p>
<p>　　大学那会儿一个破中兴的小手机触屏都坏了不少地方，我硬是坚持用了一个学期，每次发短信都特别苦恼，都得按N次才能概率性的打出某个想打的字，2333。每天都有记账，今天吃了多少钱，算算，要是超了各种负罪感有木有，然后第二天就得强迫自己少吃一点。从来没有任何额外的娱乐活动，看电影什么的还是在大三被某人在我极不情愿的状态下硬拉去的才有了第一次，衣服鞋子什么的在校从来不买，都是寒暑假回家才添置一两件，也难怪我爷爷抱怨他这个大孙子穿的土里土气的。</p>
<p>　　更难过的是因为自己太过抠门，错过了许多人和事，事还好可以补，人就无奈了。一个连自己都舍不得给自己花钱的人怎么可能舍得给别人花钱嘛，结果就因为这个闹出了不少二b的事情。大学包括研究生阶段，不止一次也不止一个妹子直接挑明了说让我请看电影请吃饭请吃什么么东西，我当时的逗逼想法是，这人怎么这样啊，就知道骗吃骗喝，然后各种鄙视那个人，至于怎么回答嘛，一般都是岔开话题不了了之，即使偶尔有去也是各买各的AA制什么的，现在想想真想抽自己一个大嘴巴子，情商太低真是个硬伤。</p>
<p>　　我算是明白了，该吃吃该喝喝，你从嘴里能省出几个钱啊，有了健康的身体才能更好的学习工作，你瞧瞧我大学那会儿那死样，瘦的跟个猴似得。我估摸着我现在即使省一年省出来的钱还不及我工作后半个月的工资，我省个毛线哦。我觉着吧无论那东西再贵，只要在自己承受范围内而且又是自己喜欢的，那就买吧，只要物尽其用，比如再贵的蛋糕只要你吃完，再贵的电子产品只要你天天用，我觉得买就不为过。有些事情在年轻的时候委屈了自己就一辈子也补不回来了，生活而不是活着。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　想通一些事情后小日子过得很是滋润，以前一直过得很苦逼，其实也不是缺钱，除了大二之前（那时候是真穷），就是舍不得花钱，一来是从小穷日子过惯了之前家里确实没钱又有一个奉行穷养的老爸穷上加穷，二来是即使后来家境稍好我爸每次给我打钱都会旁敲侧击的提醒我“十八岁了，该独立了”，搞
    
    </summary>
    
      <category term="琐事物语" scheme="http://jrhu05.github.io/categories/%E7%90%90%E4%BA%8B%E7%89%A9%E8%AF%AD/"/>
    
    
      <category term="花钱" scheme="http://jrhu05.github.io/tags/%E8%8A%B1%E9%92%B1/"/>
    
  </entry>
  
  <entry>
    <title>利用swiftype为hexo添加站内搜索v2.0</title>
    <link href="http://jrhu05.github.io/post/search-engine-for-hexo-with-swiftype-v2.html"/>
    <id>http://jrhu05.github.io/post/search-engine-for-hexo-with-swiftype-v2.html</id>
    <published>2015-10-01T07:31:13.000Z</published>
    <updated>2016-02-10T05:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　先放一下演示：<a href="http://www.jerryfu.net/search/index.html#stq=sokoban&amp;stp=1" target="_blank" rel="external">swiftype搜索演示</a></p>
<p>　　如果是已经完成了注册与网站数据的抓取，可以直接跳到step2 Install部分。</p>
<p>　　开头先废话几句，自上次写了利用“swiftype为hexo添加站内搜索”<br>（<a href="http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype.html" target="_blank" rel="external">http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype.html</a>），发现很多人用上了这个方法，很是开心。前段时间忙着玩别的东西了，所以对这个没太关注，最近查看评论的时候吓了一跳，发现好多人回复遇到了问题。</p>
<p>　　反映最多的一个问题是swiftype升级了，所以老的教程里面的很多东西找不着了，于是乎我花了点时间把自己博客所用的swiftype升级了一下。</p>
<p>　　注意swiftype有两个不同老版本的升级，分别是2013 Swiftype Search Widget和2014 Search Widget，如果是新用户的话不用关注，如果以前按照我那篇文章配置好的同学想升级的话那么你的就应该是2014 Search Widget，也即是本文适用内容，具体可以参见官方文档：<a href="https://swiftype.com/documentation/tutorials/upgrade_to_search_widget_designer" target="_blank" rel="external">https://swiftype.com/documentation/tutorials/upgrade_to_search_widget_designer</a></p>
<p>　　下面言归正传。</p>
<p>#Step1：前期准备工作#</p>
<p>　　首先，老一套的要去swiftype的网站h<a href="https://swiftype.com" target="_blank" rel="external">ttps://swiftype.com</a>注册一个账号，然后根据指引建立好自己网站对应的索引。对了有人说注册以后是30天试用，这个没关系，网站给的是30天高级账户的使用（那种有可以建立多个搜索引擎、多账户共同管理、一个引擎index多个域名的功能的账户），30天到期后你可选择花钱继续用这个高级账户（土豪自便），或者选择降级成为免费的账户类型，也就是我现在用的那种，所以，不用担心。</p>
<p>　　登陆后会自动切换到dashboard，一开始会有什么welcome to swiftype，不用搭理直接close即可。然后下面的Create an engine选项便出现了，点吧，如图所示：<br><img src="/img/search-engine-for-hexo-with-swiftype-v2/1.jpg" alt=""></p>
<p>　　然后到下一步，给你的网站建立一个索引：<br><img src="/img/search-engine-for-hexo-with-swiftype-v2/2.jpg" alt=""></p>
<p>　　接着让你输入网址，写吧：</p>
<p><img src="/img/search-engine-for-hexo-with-swiftype-v2/3.jpg" alt=""><br>　　然后让你起个名字，起吧：<br><img src="/img/search-engine-for-hexo-with-swiftype-v2/4.jpg" alt=""></p>
<p>　　然后他开始抓取你网站的数据，等等吧：<br><img src="/img/search-engine-for-hexo-with-swiftype-v2/5.jpg" alt=""></p>
<p>　　抓好之后你的dashboard会变成这个样子：</p>
<p><img src="/img/search-engine-for-hexo-with-swiftype-v2/6.jpg" alt=""></p>
<p>　　可以点进去看看抓了些什么数据：</p>
<p><img src="/img/search-engine-for-hexo-with-swiftype-v2/7.jpg" alt=""></p>
<p><img src="/img/search-engine-for-hexo-with-swiftype-v2/8.jpg" alt=""></p>
<p>　　可以看到抓了一些目录和tag数据过来，如果你不想要的话可以手动删除。</p>
<h1 id="Step2：安装配置"><a href="#Step2：安装配置" class="headerlink" title="　　Step2：安装配置"></a>　　Step2：安装配置</h1><p>　　如图，点击开始安装：<br><img src="/img/search-engine-for-hexo-with-swiftype-v2/9.jpg" alt=""></p>
<p>　　开始：<br><img src="/img/search-engine-for-hexo-with-swiftype-v2/10.jpg" alt=""></p>
<p>　　跳转到配置页面，先来配置一下外观：</p>
<p>　　SEARCH RESULTS 、AUTO COMPLETE、 COLORS改不改随意，不想折腾保持默认即可<br><img src="/img/search-engine-for-hexo-with-swiftype-v2/11.jpg" alt=""></p>
<p>　　然后保存一下，进入下一个配置：</p>
<p><img src="/img/search-engine-for-hexo-with-swiftype-v2/12.jpg" alt=""></p>
<p>　　之后会跳转到preview页面，不用搭理，直接next，这个时候会给你一个Install Code，复制一份，留待备用，我的是这个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  (function(w,d,t,u,n,s,e)&#123;w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function()&#123;</span><br><span class="line">  (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t);</span><br><span class="line">  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);</span><br><span class="line">  &#125;)(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;);</span><br><span class="line"></span><br><span class="line">  _st(&apos;install&apos;,&apos;WvPe3DphyTP1Egm6xRFi&apos;,&apos;2.0.0&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　继续next，下面开始设置search field，选择 “Yes, my site has an input field”，别的保持默认，直接next</p>
<p><img src="/img/search-engine-for-hexo-with-swiftype-v2/13.jpg" alt=""></p>
<p>　　之后便来到了Activate界面，下面需要进行结果页面的配置，如果不配置的话默认的结果展现方式是这个样子的（弹出一个结果展现框）：<br><img src="/img/search-engine-for-hexo-with-swiftype-v2/14.jpg" alt=""></p>
<p>　　如果你喜欢这种弹出式的风格的话保持默认直接active即可，如果想要实现类似我的这种单开一个页面显示搜索结果的话就要进行一下配置，点击”Edit”进行编辑<br><img src="/img/search-engine-for-hexo-with-swiftype-v2/15.jpg" alt=""></p>
<p>　　照着上图填写即可，注意把其中的网址（www.jerryfu.net）替换成自己的网址。</p>
<p>　　然后点击Save保存一下，之后active激活</p>
<p><img src="/img/search-engine-for-hexo-with-swiftype-v2/16.jpg" alt=""></p>
<p>　　至此所有的操作均已经完成。</p>
<p>　　至此swiftype网站部分的配置结束，下面要对本地的Pacman主题进行一些简单的配置就可以了。</p>
<h1 id="Step-3-hexo的Pacman主题配置"><a href="#Step-3-hexo的Pacman主题配置" class="headerlink" title="　　Step 3 hexo的Pacman主题配置"></a>　　Step 3 hexo的Pacman主题配置</h1><p>　　首先打开pacman主题下的_config.yml文件在末尾添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swift_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p>
<p>　<img src="/img/search-engine-for-hexo-with-swiftype-v2/17.jpg" alt=""></p>
<p>　　我这是添了一个swift_search的功能，你们也可以直接改掉自带的google search。</p>
<p>　　然后到hexo的source目录（注意不是pacman主题的source目录）下建立一个search文件夹，再在其下建立一个index.md，index.md中写入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: search</span><br><span class="line">title: search</span><br><span class="line">----</span><br></pre></td></tr></table></figure>
<p><img src="/img/search-engine-for-hexo-with-swiftype-v2/18.jpg" alt=""></p>
<p>　　然后再切换的到pacman\layout_partial目录下，最后需要做的收尾工作全部都在这个目录下。</p>
<p>　　先打开header.ejs，在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if	(theme.google_cse&amp;&amp;theme.google_cse.enable)&#123; %&gt;</span><br><span class="line">					&lt;form class=&quot;search&quot; action=&quot;&lt;%- config.root %&gt;search/index.html&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt;</span><br><span class="line">						&lt;label&gt;Search&lt;/label&gt;</span><br><span class="line">						&lt;input type=&quot;text&quot; id=&quot;search&quot; autocomplete=&quot;off&quot; name=&quot;q&quot; maxlength=&quot;20&quot; placeholder=&quot;&lt;%= __(&apos;search&apos;) %&gt;&quot; /&gt;</span><br><span class="line">					&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;% &#125; else &#123; %&gt;  //注意这个else前面有一个&#125;是我后加的，为了和后加的代码完成闭包</span><br><span class="line">					&lt;form class=&quot;search&quot; action=&quot;//baidu.com/search&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt;</span><br><span class="line">						&lt;label&gt;Search&lt;/label&gt;</span><br><span class="line">						&lt;input type=&quot;text&quot; id=&quot;search&quot; name=&quot;q&quot; autocomplete=&quot;off&quot; maxlength=&quot;20&quot; placeholder=&quot;&lt;%= __(&apos;search&apos;) %&gt;&quot; /&gt;</span><br><span class="line">						&lt;input type=&quot;hidden&quot; name=&quot;q&quot; value=&quot;site:&lt;%- config.url.replace(/^https?:\/\//, &apos;&apos;) %&gt;&quot;&gt;</span><br><span class="line">					&lt;/form&gt;</span><br><span class="line">					&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>　　<br>　　之间添加如下一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% &#125;else if	(theme.swift_search&amp;&amp;theme.swift_search.enable)&#123; %&gt;</span><br><span class="line">						&lt;form class=&quot;search&quot; action=&quot;&lt;%- config.root %&gt;search/index.html&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt;</span><br><span class="line">						&lt;label&gt;Search&lt;/label&gt;</span><br><span class="line">						&lt;input type=&quot;text&quot; id=&quot;search&quot; class=&quot;st-default-search-input&quot; maxlength=&quot;20&quot; placeholder=&quot;Search&quot; /&gt;</span><br><span class="line">						&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　如下所示：</p>
<p><img src="/img/search-engine-for-hexo-with-swiftype-v2/19.jpg" alt=""></p>
<p>　　注：这里和1.0版本不同的地方在于input里添加了一个class=”st-default-search-input” 的标签，这个和step2中默认的那个input class是一致的，你如果前面步骤有改过input class这里也要做相应的改动。</p>
<p>　　Header.ejs的处理完成。</p>
<p>　　接下来处理search.ejs。</p>
<p>　　将原来的search.ejs中的代码清空，替换为如下的代码：</p>
<p>　　其实主要就是为了控制结果的显示样式。</p>
<p>　　注意这里的最后的脚本代码也要为上面复制备用的你自己的那段Install Code代码。</p>
<p>　　注：对于landscape主题注意请将该部分的代码（即处理search.ejs的代码）写入到上文建立的/source/search/index.md中即可生效，感谢微博网友mmmmm57提供。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(theme.swift_search.enable) &#123; %&gt;</span><br><span class="line">&lt;div  id=&quot;container&quot; class=&quot;page&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;st-results-container&quot; class=&quot;st-search-container&quot; style=&quot;width:80%&quot;&gt;正在加载搜索结果，请稍等。&lt;/div&gt;</span><br><span class="line">  &lt;style&gt;.st-result-text &#123;</span><br><span class="line">  background: #fafafa;</span><br><span class="line">  display: block;</span><br><span class="line">  border-left: 0.5em solid #ccc;</span><br><span class="line">  -webkit-transition: border-left 0.45s;</span><br><span class="line">  -moz-transition: border-left 0.45s;</span><br><span class="line">  -o-transition: border-left 0.45s;</span><br><span class="line">  -ms-transition: border-left 0.45s;</span><br><span class="line">  transition: border-left 0.45s;</span><br><span class="line">  padding: 0.5em;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 768px) &#123;</span><br><span class="line">  .st-result-text &#123;</span><br><span class="line">    padding: 1em;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.st-result-text:hover &#123;</span><br><span class="line">  border-left: 0.5em solid #ea6753;</span><br><span class="line">&#125;</span><br><span class="line">.st-result-text h3 a&#123;</span><br><span class="line">  color: #2ca6cb;</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">  font-size: 22px;</span><br><span class="line">&#125;</span><br><span class="line">.st-snippet em &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  color: #ea6753;</span><br><span class="line">&#125;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--注意下面到&lt;/script&gt;结束的代码块要替换成自己上面保存的Install Code代码--!&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  (function(w,d,t,u,n,s,e)&#123;w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function()&#123;</span><br><span class="line">  (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t);</span><br><span class="line">  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);</span><br><span class="line">  &#125;)(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;);</span><br><span class="line"></span><br><span class="line">  _st(&apos;install&apos;,&apos;auhSjJgvzA1Ct722dXyr&apos;,&apos;2.0.0&apos;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>　　注：这里和1.0版本不同的地方在于显示内容的div里添加了一个class=”st-search-container”的标签，这个和step2中默认的那个container标签是一致的，你如果前面步骤有改过这里也要做相应的改动。</p>
<p>　　最后打开footer.ejs（其实header也行，随便你），在最后一个标签之前添加一开始拷贝的那段js代码，我的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  (function(w,d,t,u,n,s,e)&#123;w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function()&#123;</span><br><span class="line">  (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t);</span><br><span class="line">  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);</span><br><span class="line">  &#125;)(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;);</span><br><span class="line"></span><br><span class="line">  _st(&apos;install&apos;,&apos;auhSjJgvzA1Ct722dXyr&apos;,&apos;2.0.0&apos;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p>　　如下图所示：<br>　<img src="/img/search-engine-for-hexo-with-swiftype-v2/20.jpg" alt=""></p>
<p>　　至此所有的操作均已经完成。</p>
<p>　　最后你要做的只需hexo g&amp;&amp;hexo d，重新部署一下hexo即可。</p>
<p>　　Enjoying it!</p>
<p>　　转载的话请注明出处，给咱新开的小博客添点人气，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　先放一下演示：&lt;a href=&quot;http://www.jerryfu.net/search/index.html#stq=sokoban&amp;amp;stp=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;swiftype搜索演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="研究僧呀" scheme="http://jrhu05.github.io/categories/%E7%A0%94%E7%A9%B6%E5%83%A7%E5%91%80/"/>
    
    
      <category term="hexo搜索" scheme="http://jrhu05.github.io/tags/hexo%E6%90%9C%E7%B4%A2/"/>
    
      <category term="swiftype" scheme="http://jrhu05.github.io/tags/swiftype/"/>
    
  </entry>
  
  <entry>
    <title>通过向ICANN申诉转出域名</title>
    <link href="http://jrhu05.github.io/post/recapture-domain-via-complaint.html"/>
    <id>http://jrhu05.github.io/post/recapture-domain-via-complaint.html</id>
    <published>2015-08-27T07:05:31.000Z</published>
    <updated>2015-12-07T07:17:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文主要介绍咱是如何与奸商3A网络斗智斗勇拿回域名归属权。</p>
<p>　　当初乐享刚建立部署的时候站长咱还是个穷的要死的学生党（现在还是2333），而且也没啥建站的经验，所以买域名的时候直接去淘宝上面搜，结果买的最多的（鬼知道是不是刷的）就是那啥3A网络。然后一看只要35一年于是就注册了一个，然后再dnspod做了解析，用起来倒也没啥问题。</p>
<p>　　可是这个假期在给乐享升级的时候突然心血来潮想换个域名服务商结果却出现问题了，咨询3A的淘宝客服后他们告诉我说要想转必须要交100大洋，而且只能万网转万网、新网转新网，好家伙这和霸王条款有什么区别。后来我查了一下whois，居然把我的域名给锁定了，不准许转入转出，当时就怒了，有这么欺负消费者的么。</p>
<p>　　结果上网查了一下3A个渣渣是个二级代理，代理阳光互联的域名注册业务，然后我联系了阳光互联的客服，结果被告知二级代理有自己域名转出策略的话他们也管不了。我看完全就是不想管，都是一路货。本来转域名的意愿也不是很强烈，给你们这一搞我非得要把域名给转出去。</p>
<p>　　既然和代理商直接说不让，那么直接向ICANN投诉好了。ICANN是The Internet Corporation for Assigned Names and Numbers的缩写，负责域名管理等任务。同时其也接受来着域名所有者的申诉，只需要到指定的申诉界面进行相关的信息填写即可。</p>
<p>　　申诉地址如下：<a href="http://https://forms.icann.org/en/resources/compliance/complaints/transfer/form" target="_blank" rel="external">https://forms.icann.org/en/resources/compliance/complaints/transfer/form</a></p>
<p>　　Name，email，telephone num，domain name什么的如实填写即可，domain name不需要加www；</p>
<p>　　下面的理由复选框照着这样勾选即可：<br><img src="/img/recapture-domain-via-complaint/1.jpg" alt=""></p>
<p>　　然后接下来是让你写一些detail信息，随便写点抱怨的XXX，请求XXX之类的，我的是这样写的（英语渣）：</p>
<blockquote>
<p>Comments: Dear ICANN:    I registered my domain xxx.com at sundns.com. I am not satisfied with their service and I want to transfer my domain to other companies.But I can’t find any place on their site to get my Auth-Info code. Followed their FAQ, their say that they will not provide the auth code to me if I don&#039;t pay 100 RMB to them.    I think I am the domain owner and I have the right of transfering my domain by free. But many domain agents in China (not only )always set up many check points and collect fees to avoid customers transfering domain out of them.    Please send the auth code of (xxx.com) to it’s owner email.I want my domain transfer code, and complete the transfer as soon as possible.    thank you very much.    Hu.</p>
</blockquote>
<p>　　对了注意在发起申诉之前把whois信息保护给关了，不然ICANN无法验证域名的归属权，你还得多折腾一次，我开始时就给忘了。</p>
<p>　　如果你没有关闭whois信息保护ICANN会给你回这样的邮件：</p>
<blockquote>
<p>Transfer requests can only be processed when they are submitted by a Transfer Contact (i.e., the Registered Name Holder or Administrative Contact). Since the domain name referenced in your complaint is currently registered behind a privacy service, it is not possible for the registrar of record to determine if you are a Transfer Contact. Please lift the privacy service so that you are listed in the Whois data as a Transfer Contact. </p>
</blockquote>
<p>　　关闭whois保护后，回复ICANN的那封邮件（不要改主题），然后没几天ICANN就给我回另一封封邮件，让我提供能表明我向代理商发出了索要域名转移码请求而他们没鸟我的证据，摘录如下：</p>
<blockquote>
<p>Please provide evidence (such as emails, customer service tickets, or date and time of telephone calls) that you have already taken these four steps, that are required for ICANN to be able to start its standard Contractual Compliance process regarding domain name transfers:<br>(1) You must have already requested the AuthInfo code from the registrar, and did not receive it within 5 days from the date of your request; and<br>(2) You must have already requested the registrar of record to unlock the domain name but it was not unlocked within five days following the date of your request.</p>
</blockquote>
<p>Please send the information and records requested above via reply email (no more than 4 MB total) and do not change the email subject heading. Please provide records as attachments in .TXT, .PDF, or .DOC(X) format. </p>
<p>　　然后我因为我是在淘宝上买的，所以我回了封邮件问他们QQ和淘宝聊天记录算不算证据，还有中文他们能不能看懂什么的（当然我是用英语问来着）。</p>
<p>　　然后他们华丽丽的用中文给我回了一封邮件2333…</p>
<p>　　内容如下：</p>
<p>　　请提供证据（比如电子邮件，客户服务单或者通话日期和时间）证明您已经采取了如下四个步骤，以便ICANN开始其关于域名转出事宜的标准合同合规程序：</p>
<p>　　(1)您必须已经要求注册商提供转移密码，但是自要求之日起五天内没有获得转移密码；并且</p>
<p>　　(2)您必须已经要求注册商将该域名解锁，但是自要求之日起五日内该域名没有被解锁。</p>
<p>　　请通过邮件回复以上信息和记录（总大小不要超过4MB）并且不要修改邮件主题。请以.TXT, .PDF, or .DOC(X)格式的附件来提供。</p>
<p>　　好吧，我给就是了。</p>
<p>　　我把和3a客服和sundns客服的聊天记录截了图放到了一个word里，然后又把sundns域名服务员回我的邮件给转成了pdf，放到了附件里，邮件正文稍加说明然后回给了ICANN，大致如下：</p>
<blockquote>
<p>The chat recording and email information are in the attachments. Please verify it.</p>
</blockquote>
<p>聊天截图:</p>
<p><img src="/img/recapture-domain-via-complaint/2.jpg" alt=""></p>
<p>邮件pdf：</p>
<p><img src="/img/recapture-domain-via-complaint/3.jpg" alt=""></p>
<p>　　然后等吧，没几天阳光互联就给我发邮件来了，转移码什么的也一并发过来了。</p>
<p><img src="/img/recapture-domain-via-complaint/4.jpg" alt=""></p>
<p>　　然后就可以随意转域名了，enjoying it!</p>
<p>　　没想到ICANN又给我回了封邮件，内容如下：</p>
<blockquote>
<p>Dear XXX,Thank you for submitting a Transfer complaint concerning the domain name XXX.com. ICANN has reviewed and closed your complaint because:- The registrar of record provided ICANN with copy of the written communications in which the AuthInfo code was sent to the Registered Name Holder of the affected domain name. In addition, the current Whois database shows that the domain name is not locked.ICANN considers this matter now closed.  If you require future assistance, please submit a new complaint to ICANN at <a href="http://www.icann.org/resources/compliance/complaints" target="_blank" rel="external">http://www.icann.org/resources/compliance/complaints</a> .Please do not reply to this email (replies to closed complaints are not monitored by ICANN staff).ICANN is requesting your feedback on this closed complaint. Please complete this optional survey at <a href="https://www.surveymonkey.com/s/8F2Z6DP" target="_blank" rel="external">https://www.surveymonkey.com/s/8F2Z6DP</a> .Sincerely,ICANN Contractual Compliance</p>
</blockquote>
<p>　　大致就是发现域名代理商已经把转移码发给你啦，而且域名也被解锁，任务结束关闭工单之类的。</p>
<p>　　ICANN简直贴心的不要不要的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文主要介绍咱是如何与奸商3A网络斗智斗勇拿回域名归属权。&lt;/p&gt;
&lt;p&gt;　　当初乐享刚建立部署的时候站长咱还是个穷的要死的学生党（现在还是2333），而且也没啥建站的经验，所以买域名的时候直接去淘宝上面搜，结果买的最多的（鬼知道是不是刷的）就是那啥3A网络。然后一看只
    
    </summary>
    
      <category term="研究僧呀" scheme="http://jrhu05.github.io/categories/%E7%A0%94%E7%A9%B6%E5%83%A7%E5%91%80/"/>
    
    
      <category term="域名申诉" scheme="http://jrhu05.github.io/tags/%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%89/"/>
    
  </entry>
  
  <entry>
    <title>借力七牛云乐享假期升级</title>
    <link href="http://jrhu05.github.io/post/upgrade-hytcshare-with-qiniu-cloud.html"/>
    <id>http://jrhu05.github.io/post/upgrade-hytcshare-with-qiniu-cloud.html</id>
    <published>2015-08-04T05:55:10.000Z</published>
    <updated>2015-12-07T07:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　因为下学期老师实验室项目的需要，这个暑假在家恶补了一下PHP，每天六七个小时的视频看的我头晕眼花。还好讲课的韩老师讲的很有趣，要不然估计早弃掉了。学到一半的时候突然觉得应该学以致用，找点东西练练手，然后很自然的想到了曾经大一时候弄过的乐享项目，也是PHP的，基于phpdisk修改而来。</p>
<p>　　如果是奔着七牛云部分来的，可以直接跳到最后的第五点。</p>
<p>　　其中有一些零零散散的升级，例如对mydisk.php的修改，原来是登录后跳转到学术E盘的上传界面（即每个人独立的私人空间），后来感觉每个人上传到自己单独的空间太麻烦了。于是我直接就把这块给砍掉了，现在登录后直接跳转到分好类的几十个公共上传界面，选择相应的上传目的父类即可，十分简洁明了。</p>
<p>　　第二个较为直观的升级点是对主页随机band的动态化修改。当初进行乐享项目开发的时候还是一个啥都不懂的大一小朋友，只会一些基础的html、css，PHP什么的完全不懂，所以为了实现首页随机band条的效果只好用最笨的html+js控制的方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- saved from url=(0042)http://www.gdutlx.com/wb/index_random.html --&gt;</span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;</span><br><span class="line">&lt;META content=&quot;text/html; charset=utf-8&quot; http-equiv=Content-Type&gt;</span><br><span class="line">&lt;META name=GENERATOR content=&quot;MSHTML 8.00.6001.18702&quot;&gt;&lt;/HEAD&gt;</span><br><span class="line">&lt;BODY topMargin=0 bgColor=#D0FFD0&gt;</span><br><span class="line">&lt;CENTER&gt;</span><br><span class="line"> &lt;DIV id=adpic&gt;</span><br><span class="line">&lt;IMG style=&quot;DISPLAY: none&quot; src=&quot;index_random_files/10.gif&quot;&gt; </span><br><span class="line">&lt;IMG style=&quot;DISPLAY: none&quot; src=&quot;index_random_files/18.gif&quot;&gt; </span><br><span class="line">&lt;IMG style=&quot;DISPLAY: none&quot; src=&quot;index_random_files/23.gif&quot;&gt; </span><br><span class="line">&lt;IMG style=&quot;DISPLAY: none&quot; src=&quot;index_random_files/26.gif&quot;&gt; </span><br><span class="line">&lt;IMG style=&quot;DISPLAY: none&quot; src=&quot;index_random_files/27.gif&quot;&gt; &lt;/DIV&gt;</span><br><span class="line">&lt;SCRIPT language=JavaScript type=text/javascript&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">function runad()</span><br><span class="line">&#123;</span><br><span class="line">var ads=document.getElementById(&quot;adpic&quot;).getElementsByTagName(&quot;img&quot;)</span><br><span class="line">for(var i=0,adsc=ads.length;i&lt;adsc;i++)</span><br><span class="line">&#123;</span><br><span class="line">ads[i].style.display=&apos;none&apos;;</span><br><span class="line">&#125;</span><br><span class="line">ads[parseInt(Math.random()*ads.length)].style.display=&apos;&apos;;</span><br><span class="line">&#125;</span><br><span class="line">function run()</span><br><span class="line">&#123;</span><br><span class="line">//广告执行函数</span><br><span class="line">runad();</span><br><span class="line">&#125;</span><br><span class="line">window.onload=run</span><br><span class="line">//--&gt;</span><br><span class="line">&lt;/SCRIPT&gt;</span><br><span class="line">&lt;/CENTER&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- &lt;p&gt;&lt;embed width=&quot;1&quot; height=&quot;1&quot; src=&quot;http://www.xiami.com/widget/61405_2121966,_1_1_FF8719_494949_1/multiPlayer.swf&quot; type=&quot;application/x-shockwave-flash&quot; wmode=&quot;transparent&quot; allowscriptaccess=&quot;never&quot; /&gt;&lt;/p&gt;</span><br><span class="line">//--&gt;</span><br><span class="line"></span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　这样做有一个极为致命的缺点，即所有的随机图片都需要先下载到本地，再由js进行控制随机显示哪一个，这样就导致即使在随机库很小的情况下（如本例中只有5个图片）加载也会出现一到两秒的滞后，更别说如果想增加更多的图片了。结果这个困扰了我很久的问题在我学习PHP的第二天讲到数学函数的时候我就想到了完美的解决方法。各位大概已经猜到了，是的，random函数。先规则化的命名所有图片，例如从1到20，然后随机产生一个1到20之间的整数，最后拼接完成最终的图片路径再echo即可，so easy，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;</span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;</span><br><span class="line">&lt;META content=&quot;text/html; charset=gb2312&quot; http-equiv=Content-Type&gt;</span><br><span class="line">&lt;/HEAD&gt;</span><br><span class="line">&lt;BODY topMargin=0 bgColor=#D0FFD0&gt;</span><br><span class="line">&lt;CENTER&gt;</span><br><span class="line"> &lt;DIV id=adpic&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">	$randId=rand(1,18);</span><br><span class="line">	$img = &apos;self_add/index_random_files/&apos;.$randId.&apos;.gif&apos;;</span><br><span class="line">	echo &apos;&lt;img src=&quot;&apos;.$img.&apos;&quot; alt=&quot;hytcshare&quot; /&gt;&apos;;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;/DIV&gt;</span><br><span class="line"></span><br><span class="line">&lt;/CENTER&gt;</span><br><span class="line">&lt;!--注释部分是虾米音乐的代码--&gt;</span><br><span class="line">&lt;!--&lt;p&gt;&lt;embed width=&quot;1&quot; height=&quot;1&quot; src=&quot;http://www.xiami.com/widget/61405_2121966,_1_1_FF8719_494949_1/multiPlayer.swf&quot; type=&quot;application/x-shockwave-flash&quot; wmode=&quot;transparent&quot; allowscriptaccess=&quot;never&quot; /&gt;&lt;/p&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　由于每个图片单独都很小，至多100k，所以首页展现速度大大提升，基本做到了秒开的地步，堪称完美。</p>
<p><img src="/img/upgrade-hytcshare-with-qiniu-cloud/band.jpg" alt=""></p>
<p>　　第三个升级的小点是对登录后主界面的个人信息展示进行了修改，增加了个人积分显示这一项，同时直接计算出能下载的文件数目，并且用红色高亮来突出，具体效果如下：</p>
<p><img src="/img/upgrade-hytcshare-with-qiniu-cloud/selfInfo.jpg" alt=""></p>
<p>　　（当然这么多积分是拿来测试的啦），当然改起来也很简单，在首页的tpl模板文件中相对应的位置添加这样一段即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;邮箱地址: &lt;?=$pd_email?&gt;&lt;/li&gt;	</span><br><span class="line">				&lt;li&gt;剩余积分: &lt;span class=&quot;txtred&quot;&gt;&lt;strong&gt;&lt;?=$myinfo[credit]?&gt;&lt;/strong&gt;&lt;/span&gt; (可下载&lt;?echo round($myinfo[credit]/2)?&gt;个文件）&lt;/li&gt;&lt;/br&gt;</span><br></pre></td></tr></table></figure></p>
<p>　　第四个升级的点是修改了一下用户激活的业务逻辑，原来的乐享未激活只是无法上传文件，下载不受影响，本来也是出于好意。哪想到有人发现了这一点，所以注册的时候随便瞎填一个邮箱，也不激活，直接下载完注册送的10个积分便重新注册新的账号，严重违反了游戏规则。不得以只好修改了逻辑规则，现在新注册的用户必须完成邮箱激活后才能进行正常的下载与上传。如图所示：</p>
<p><img src="/img/upgrade-hytcshare-with-qiniu-cloud/activate1.jpg" alt=""></p>
<p>　<br>　　改动也不大，只需要在原来的显示下载文件详情页面的pd_viewfile.tpl.php页面中相应的位置增加如下的判断代码即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php if($settings[&apos;login_down_file&apos;] &amp;&amp; !$pd_uid &amp;&amp; $file[&apos;userid&apos;])&#123; ?&gt;</span><br><span class="line">	&lt;span class=&quot;file_login&quot;&gt;&lt;?=$L[&apos;file_down_tips&apos;]?&gt;&lt;/span&gt;</span><br><span class="line">	&lt;?php &#125;elseif(!$pd_is_activated)&#123;echo &apos;未激活同学无法下载文件，要先进行激活操作哦。&apos;;</span><br><span class="line">	echo &apos; &lt;a href=&quot;account.php?action=active&quot;&gt;&lt;span class=&quot;txtred&quot;&gt;点我激活&lt;/span&gt;&lt;/a&gt;&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	elseif(!$file[&apos;is_checked&apos;] &amp;&amp; $pd_gid&lt;&gt;1)&#123; ?&gt;...</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p>　　此外还对下载界面的提示信息进行了更为友好的改动，如下所示：</p>
<p><img src="/img/upgrade-hytcshare-with-qiniu-cloud/activate2.jpg" alt=""></p>
<p>　　第五点即是本文的重点，利用七牛云的免费云存储实现资料的云端化。本来乐享的资料是上传到本地服务器的，这样一来随着网站运行时间的增加，越来越多的同学把资料上传到了网站上面，网站的非程序性空间占用越来越大，随之而来的是对主机空间的要求也越来越高。而站长我穷的要死，弄一个香港的独立IP已经是极限了，这样下去维持个一年半载的也不是个办法，因此能否利用七牛云认证账户免费的10GB存储空间和每月10GB流量来优化乐享现有的构架呢？答案是肯定的，而且实现起来也不难。首先我不打算开放普通用户将文件上传到我的七牛云空间的权限，所以改版计划和最终完成的都是由我进行审核与上传，普通的用户还是走原来的通道。</p>
<p>　　为了实现与原来的操作模式相分离，一定会需要对数据库的pdfile表进行操作，我对该表增加了一个is_cloud字段，默认为0表示非云文件，值为1则表示是云化的文件。由于没有改动原上传文件的逻辑，因此普通用户上传的时候写入数据库数据时is_cloud字段由于没有赋值所以默认为0即对原来的逻辑没有任何影响。由我筛选整理后将文件上传到七牛云，然后将对应的记录设为1，为了简化操作，我在后台单独写了一个管理页面，操作也很简单，即对选中的文件记录进行更新pdfile表is_cloud字段置为1的操作。完成数据库的操作后，再对download.php进行少许的改动即可，首先是从数据库中取出is_cloud字段的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$is_cloud = $rs[&apos;is_cloud&apos;];</span><br><span class="line">if(!$is_cloud)&#123;</span><br><span class="line">//...原来的普通构建header方式的常规下载方式</span><br><span class="line">&#125;else&#123;</span><br><span class="line">		//七牛云部分		</span><br><span class="line">		$url=&quot;http://xxxxxx.xxx.xx.xxx.xxxxx.com/&quot;;//hytcshare七牛云对应的路径前缀(每个人都不同的，可以到自己的七牛云平台上查看)（这里不方便透漏）</span><br><span class="line">		$abbr=&quot;XXXXX-&quot;;//文件前缀（如果有的话）（这里不方便透露）</span><br><span class="line">//获取文件真实的文件名</span><br><span class="line">		$qiniu_url=urlencode(iconv(&apos;GBK&apos;, &apos;UTF-8&apos;, $file_name));//数据库传过来的是gbk字符集，这里需要的是utf-8，所以要把gbk转为utf-8</span><br><span class="line">//由于七牛云支持http直接请求，所以只需要拼接完地址后直接跳转即可完成下载</span><br><span class="line">		header(&quot;Location:  &quot;.$url.$abbr.$qiniu_url);</span><br><span class="line">		exit;</span><br><span class="line">	&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>　　大功告成！附上前后空间占用的对比图：</p>
<p>　　原来：<br><img src="/img/upgrade-hytcshare-with-qiniu-cloud/origin.png" alt=""></p>
<p>　　现在：</p>
<p><img src="/img/upgrade-hytcshare-with-qiniu-cloud/now.png" alt=""></p>
<p>　　妈妈再也不用担心我买不起大空间主机啦，♪(^∇^*)！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　因为下学期老师实验室项目的需要，这个暑假在家恶补了一下PHP，每天六七个小时的视频看的我头晕眼花。还好讲课的韩老师讲的很有趣，要不然估计早弃掉了。学到一半的时候突然觉得应该学以致用，找点东西练练手，然后很自然的想到了曾经大一时候弄过的乐享项目，也是PHP的，基于phpd
    
    </summary>
    
      <category term="研究僧呀" scheme="http://jrhu05.github.io/categories/%E7%A0%94%E7%A9%B6%E5%83%A7%E5%91%80/"/>
    
    
      <category term="七牛云" scheme="http://jrhu05.github.io/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>回朔法的相关实例</title>
    <link href="http://jrhu05.github.io/post/back-tracking-algorithm.html"/>
    <id>http://jrhu05.github.io/post/back-tracking-algorithm.html</id>
    <published>2015-06-11T14:43:17.000Z</published>
    <updated>2015-06-11T14:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　之前的课老师给我们讲了回溯法，回溯法从本质上来说并不能减低问题规模的量级，只是通过一定的约束条件减少了问题规模的常数项系数。回溯法的基本做法是搜索，它是一种可以避免不必要搜索的穷举式搜索法。</p>
<p>　　回溯法是采用深度优先的思想进行遍历，而分枝限界法采用的是广度优先遍历，两者从本质上来说没有太大的区别，剪枝函数的选取也大致相同，所以分支限界法不再进行相关的实例实现。</p>
<p>　　回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分枝限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。</p>
<p>　　回溯法适用于求解一些组合数较大的问题，典型的如m图着色问题、N后问题、01背包问题、符号三角形问题、TSP问题等。</p>
<p>　　回溯法常见的两类解空间树大致有两种，子集树和排列树，子集树如01背包问题的解空间树，排列数树如TSP问题的解空间树。</p>
<p>　　下面给出两者的基本demo：</p>
<p>　　子集树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package backtrackingAlgorithm;</span><br><span class="line">/**</span><br><span class="line"> * 子集树演示</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SubsetTreeTest &#123;</span><br><span class="line">	static int N=3;//深度</span><br><span class="line">	static int[] x=new int[N+1];</span><br><span class="line">	static void Backtrace(int t)</span><br><span class="line">	&#123;</span><br><span class="line">	    if(t&gt;N)</span><br><span class="line">	    &#123;</span><br><span class="line">	        for(int i=1;i&lt;=N;i++)</span><br><span class="line">	        &#123;</span><br><span class="line">	        	System.out.print(x[i]+&quot; &quot;);</span><br><span class="line">	        &#125;</span><br><span class="line">	        System.out.println();</span><br><span class="line">	    &#125;</span><br><span class="line">	    else</span><br><span class="line">	    &#123;</span><br><span class="line">	        for(int i=0;i&lt;=1;i++)</span><br><span class="line">	        &#123;</span><br><span class="line">	            x[t]=i;</span><br><span class="line">	            Backtrace(t+1);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Backtrace(1);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　　排列树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package backtrackingAlgorithm;</span><br><span class="line">/**</span><br><span class="line"> * 排列树演示</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class PermutationTreeTest &#123;</span><br><span class="line">	static int N=3;</span><br><span class="line">	static int[] x=&#123;0,1,2,3&#125;;</span><br><span class="line">	static void swap(int x1,int x2)</span><br><span class="line">	&#123;</span><br><span class="line">	    int temp=x[x1];</span><br><span class="line">	    x[x1]=x[x2];</span><br><span class="line">	    x[x2]=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	static void Backtrace(int t)</span><br><span class="line">	&#123;</span><br><span class="line">	    if(t&gt;N)</span><br><span class="line">	    &#123;</span><br><span class="line">	        for(int i=1;i&lt;=N;i++)</span><br><span class="line">	        &#123;</span><br><span class="line">	        	System.out.print(x[i]+&quot; &quot;);</span><br><span class="line">	        &#125;</span><br><span class="line">	       System.out.println();</span><br><span class="line">	    &#125;</span><br><span class="line">	    else</span><br><span class="line">	    &#123;</span><br><span class="line">	        for(int i=t;i&lt;=N;i++)</span><br><span class="line">	        &#123;</span><br><span class="line">	            swap(t,i); //意思是这个swap(x[t],x[i]);</span><br><span class="line">	            Backtrace(t+1);</span><br><span class="line">	            swap(t,i); //swap(x[t],x[i]);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Backtrace(1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　下面给出一些常见的经典实例的实现，基本上就是对上述两个demo的灵活应用。</p>
<p>　　01背包问题的回朔法求解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package backtrackingAlgorithm;</span><br><span class="line">/**</span><br><span class="line"> * 01背包问题的回朔法求解</span><br><span class="line"> *  回溯法：01背包属于找最优解问题，用回溯法需要构造解的子集树。在搜索状态空间树时，</span><br><span class="line"> *  只要左子节点是可一个可行结点，搜索就进入其左子树。对于右子树时，先计算上界函数，以判断是否将其减去，剪枝</span><br><span class="line"> *  限界函数:当前价值cv+剩余容量可容纳的最大价值&lt;=当前最优价值bestv，那么就进行剪枝，</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class OneZeroPackage &#123;</span><br><span class="line">	static int c;  //背包最大容量</span><br><span class="line">	static int n;  //子集树的深度，即物品个数</span><br><span class="line">	static int []w;  //物品重量w[i]</span><br><span class="line">	static int []v;  //物品价值v[i]</span><br><span class="line">	static int cw;  //当前物品总重（currentWeight）</span><br><span class="line">	static int cv;  //当前物品总价值（currentValue）</span><br><span class="line">	static int bestv;  //最优解</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] wight=&#123;20,15,10&#125;;</span><br><span class="line">		int[] value=&#123;20,30,25&#125;;</span><br><span class="line">		int maxWight=25;</span><br><span class="line">		System.out.println(Knapsack(value, wight, maxWight));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static int Knapsack(int []vv,int []ww,int cc)  </span><br><span class="line">	&#123;  </span><br><span class="line">		//初始化</span><br><span class="line">		c=cc;  </span><br><span class="line">		n=vv.length-1;  </span><br><span class="line">		cw=0;  </span><br><span class="line">		cv=0;  </span><br><span class="line">		bestv=0;   </span><br><span class="line">		v=vv;</span><br><span class="line">		w=ww;</span><br><span class="line">		//进行回溯操作</span><br><span class="line">		backtrack(0);  </span><br><span class="line">		return bestv;  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 递归式的回溯法实现</span><br><span class="line">	 * @param i 递归出发点</span><br><span class="line">	 */</span><br><span class="line">	static void backtrack(int i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		//如果到达叶子节点，即表明找到一个可行解</span><br><span class="line">		//则将当前解返回</span><br><span class="line">		if(i&gt;n)  </span><br><span class="line">		&#123;  </span><br><span class="line">			bestv=cv;  </span><br><span class="line">			return;  </span><br><span class="line">		&#125;  </span><br><span class="line">		//如果可以放入第i个物品（即可以遍历左子树），</span><br><span class="line">		//则放入并且更新cw和cv</span><br><span class="line">		if(cw+w[i]&lt;=c) //此即为约束函数类剪枝函数 </span><br><span class="line">		&#123;  </span><br><span class="line">			cw+=w[i];  </span><br><span class="line">			cv+=v[i]; </span><br><span class="line">			//进行左子树遍历</span><br><span class="line">			backtrack(i+1);  </span><br><span class="line">			//左子树遍历完成后进行回溯，回溯到当前节点</span><br><span class="line">			//即对cw和cv进行更新</span><br><span class="line">			cw-=w[i];  </span><br><span class="line">			cv-=v[i];  </span><br><span class="line">		&#125;  </span><br><span class="line">		//左子树遍历完成后，判断是否有可能产生比当前最优解还要大的解，如果可能则遍历右子树</span><br><span class="line">		if(bound(i+1)&gt;bestv)  //此即为限界函数类剪枝函数</span><br><span class="line">			backtrack(i+1);  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 计算从节点i开始的上界函数（即当前价值cv+剩余容量可容纳的最大价值）</span><br><span class="line">	 * @param i</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	private static double bound(int i)  </span><br><span class="line">	&#123;  </span><br><span class="line">		double cleft=c-cw;  //背包剩余容量</span><br><span class="line">		double bound=cv;  //如果i已经到了最后，那么没东西可以再放，即cv为上界</span><br><span class="line">		//一个个的加，直到无法再放了</span><br><span class="line">		//w[i]&lt;=cleft是为了保证这个东西能完整的放进去</span><br><span class="line">		while(i&lt;=n&amp;&amp;w[i]&lt;=cleft)  </span><br><span class="line">		&#123;  </span><br><span class="line">			cleft-=w[i];  </span><br><span class="line">			bound+=v[i];  </span><br><span class="line">			i++;  </span><br><span class="line">		&#125;  		</span><br><span class="line">		return bound;  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　图的M着色问题的回溯法求解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package backtrackingAlgorithm;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 图的M着色问题的回溯法求解</span><br><span class="line"> * 图用邻接矩阵来表示</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class theIssueOfColoringUpPictures &#123;</span><br><span class="line">	static int[][] map=&#123;&#123;0,1,1,0,0&#125;,</span><br><span class="line">					 	&#123;1,0,1,1,1&#125;,</span><br><span class="line">					 	&#123;1,1,0,0,1&#125;,</span><br><span class="line">					 	&#123;0,1,0,0,1&#125;,</span><br><span class="line">					 	&#123;0,1,1,1,0&#125;&#125;;</span><br><span class="line">	</span><br><span class="line">	static int[] color=&#123;0,0,0,0,0&#125;;</span><br><span class="line">	static int n=color.length;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String[] colorSet=&#123;&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;&#125;;</span><br><span class="line">		CUPicBackAlgo(0,0);</span><br><span class="line">		for (int i = 0; i &lt; color.length; i++) &#123;</span><br><span class="line">			System.out.print(colorSet[color[i]]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int CUPicBackAlgo(int deep,int flag) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		if (deep&gt;=n) &#123;</span><br><span class="line">			//找到一组可行解</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			for(int i=flag;i&lt;3;i++)&#123;//有三种颜色</span><br><span class="line">				color[deep]=i;</span><br><span class="line">				if (check(deep)) &#123;</span><br><span class="line">					System.out.println(Arrays.toString(color));</span><br><span class="line">					if (CUPicBackAlgo(deep+1,0)==0) &#123;</span><br><span class="line">						//一旦找到可行解就断开for循环</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;else if (i==2) &#123;//如果该节点所有的解都不满足条件那么进行回溯</span><br><span class="line">					System.out.println(Arrays.toString(color));</span><br><span class="line">					System.out.println(&quot;back track&quot;);</span><br><span class="line">					CUPicBackAlgo(deep-1,color[deep-1]+1);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static boolean check(int deep) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		//检查颜色是否满足要求</span><br><span class="line">		for (int i = 0; i &lt; deep; i++) &#123;</span><br><span class="line">			if (map[deep][i]==1&amp;&amp;color[i]==color[deep]) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　旅行商问题的回溯法求解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package backtrackingAlgorithm;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 旅行商问题的回溯法求解</span><br><span class="line"> * Travel Salesman Problem</span><br><span class="line"> * 图用邻接矩阵来表示</span><br><span class="line"> * 解空间是序列树</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TSP &#123;</span><br><span class="line">	static int NUM=4;</span><br><span class="line">	//static int MAX=Integer.MAX_VALUE; </span><br><span class="line">	static int MAX=Integer.MAX_VALUE; </span><br><span class="line">	//图G的邻接矩阵</span><br><span class="line">	static int[][] map=&#123;&#123;0,0,0,0,0&#125;,</span><br><span class="line">					    &#123;0,MAX,30,6,4&#125;,</span><br><span class="line">					    &#123;0,30,MAX,5,10&#125;,</span><br><span class="line">					    &#123;0,6,5,MAX,20&#125;,</span><br><span class="line">					    &#123;0,4,10,20,MAX&#125;&#125;;      </span><br><span class="line">	static int[] currentx=&#123;1,1,2,3,4&#125;;     //当前解  </span><br><span class="line">	static int[] bestx=&#123;0,0,0,0,0,1&#125;;     //最优解,顺序输出即可  </span><br><span class="line">	static int cc=0;         //当前费用  </span><br><span class="line">	//static int NoEdge=-1;      //无边标记  </span><br><span class="line">	static int bestc=-1;      //最优费用  </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	static void BackTrack(int t)       //t从2开始  </span><br><span class="line">	&#123;  </span><br><span class="line">	    //到达第n个节点  </span><br><span class="line">	    if(t&gt;NUM)  </span><br><span class="line">	    &#123;  </span><br><span class="line">	        if(cc+map[currentx[NUM-1]][currentx[NUM]]+map[currentx[NUM]][1]&lt;bestc)  </span><br><span class="line">	        &#123;  </span><br><span class="line">	             for(int i=1;i&lt;=NUM;i++)  </span><br><span class="line">	             &#123;  </span><br><span class="line">	                bestx[i]=currentx[i];  </span><br><span class="line">	             &#125;  </span><br><span class="line">	             bestc=cc+map[currentx[NUM-1]][currentx[NUM]]+map[currentx[NUM]][1];  </span><br><span class="line">	             System.out.print(Arrays.toString(bestx)+&quot;---&gt;&quot;); </span><br><span class="line">	             System.out.println(countPrice());</span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    else  </span><br><span class="line">	    &#123;  </span><br><span class="line">	        for(int i=t;i&lt;=NUM;i++)  </span><br><span class="line">	        &#123;  </span><br><span class="line">	            //如果上一个节点和它此后的节点有边,并且费用不高于现有的最优费用(bestc==-1表示第一次)  </span><br><span class="line">	            if(cc+map[currentx[t-1]][currentx[i]]&lt;bestc ||bestc==-1)  </span><br><span class="line">	            &#123;  </span><br><span class="line">	                swap(t,i);  </span><br><span class="line">	                cc+=map[currentx[t-1]][currentx[t]];  </span><br><span class="line">	                BackTrack(t+1);  </span><br><span class="line">	                cc-=map[currentx[t-1]][currentx[t]];  </span><br><span class="line">	                swap(t,i);  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	  </span><br><span class="line">	&#125;//注,此时默认currentx[1]==1,即从第一个节点出发  </span><br><span class="line">	</span><br><span class="line">	static void swap(int x1, int x2) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		int temp=currentx[x1];</span><br><span class="line">		currentx[x1]=currentx[x2];</span><br><span class="line">		currentx[x2]=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private static int countPrice() &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		int best=0;</span><br><span class="line">		for (int i = 1; i &lt; bestx.length-1; i++) &#123;</span><br><span class="line">			best+=map[bestx[i]][bestx[i+1]];</span><br><span class="line">		&#125;</span><br><span class="line">		return best;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		BackTrack(1);</span><br><span class="line">        System.out.print(Arrays.toString(bestx)+&quot;---&gt;&quot;); </span><br><span class="line">        System.out.print(countPrice());</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　八皇后问题的回朔法求解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package backtrackingAlgorithm;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 八皇后问题的回朔法求解</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class NQueensWithBacAlo &#123;</span><br><span class="line">	 // 皇后的个数  </span><br><span class="line">    private static int queensNum = 8;  </span><br><span class="line"> </span><br><span class="line">    // column[i] = j 表示第 i 列的第 j 行放置一个皇后  </span><br><span class="line">    private static int[] queens = new int[queensNum + 1];  </span><br><span class="line"> </span><br><span class="line">    // rowExists[i] = true 表示第 i 行有皇后  </span><br><span class="line">    private boolean[] rowExists = new boolean[queensNum + 1];  </span><br><span class="line"> </span><br><span class="line">    // a[i] = true 表示右高左低的第 i 条斜线有皇后  </span><br><span class="line">    private boolean[] a = new boolean[queensNum * 2];  </span><br><span class="line"> </span><br><span class="line">    // b[i] = true 表示左高右低的第 i 条斜线有皇后  </span><br><span class="line">    private boolean[] b = new boolean[queensNum * 2];  </span><br><span class="line">      </span><br><span class="line">    // 初始化变量  </span><br><span class="line">    private void init() &#123;  </span><br><span class="line">        for (int i = 0; i &lt; queensNum + 1; i++) &#123;  </span><br><span class="line">            rowExists[i] = false;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        for(int i = 0; i &lt; queensNum * 2; i++) &#123;  </span><br><span class="line">            a[i] = b[i] = false;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    // 判断该位置是否已经存在一个皇后,存在则返回 true  </span><br><span class="line">    private boolean isExists(int row, int col) &#123;  </span><br><span class="line">        return (rowExists[row] || a[row + col - 1] || b[queensNum + col - row]);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    // 主方法：测试放置皇后  </span><br><span class="line">    public void testing(int column) &#123;  </span><br><span class="line"> </span><br><span class="line">        // 遍历每一行  </span><br><span class="line">        for (int row = 1; row &lt; queensNum + 1; row++) &#123;  </span><br><span class="line">            // 如果第 row 行第 column 列可以放置皇后  </span><br><span class="line">            if (!isExists(row, column)) &#123;  </span><br><span class="line">                // 设置第 row 行第 column 列有皇后   </span><br><span class="line">                queens[column] = row;  </span><br><span class="line">                // 设置以第 row 行第 column 列为交叉点的斜线不可放置皇后  </span><br><span class="line">                rowExists[row] = a[row + column - 1] = b[queensNum + column - row] = true;  </span><br><span class="line">                  </span><br><span class="line">                // 全部尝试过，打印  </span><br><span class="line">                if(column == queensNum) &#123;  </span><br><span class="line">                    for(int col = 1; col &lt;= queensNum; col++) &#123;  </span><br><span class="line">                        System.out.print(&quot;(&quot;+col + &quot;,&quot; + queens[col] + &quot;)  &quot;);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    System.out.println(); </span><br><span class="line">                    </span><br><span class="line">                    int[][] map=new int[queensNum][queensNum];</span><br><span class="line">                    for (int[] is : map) &#123;</span><br><span class="line">            			for (int i : is) &#123;</span><br><span class="line">            				i=0;</span><br><span class="line">            			&#125;</span><br><span class="line">            		&#125;</span><br><span class="line">                    for(int col = 1; col &lt;= queensNum; col++) &#123;  </span><br><span class="line">                    	map[col-1][queens[col]-1]=1;</span><br><span class="line">                        //System.out.print(&quot;(&quot;+col + &quot;,&quot; + queens[col] + &quot;)  &quot;);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    System.out.println();</span><br><span class="line">                    for (int[] is : map) &#123;</span><br><span class="line">                    	for (int i : is) &#123;</span><br><span class="line">            				System.out.print(i+&quot; &quot;);</span><br><span class="line">            			&#125;</span><br><span class="line">                    	System.out.println();</span><br><span class="line">            		&#125;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;else &#123;  </span><br><span class="line">                    // 放置下一列的皇后  </span><br><span class="line">                    testing(column + 1);  </span><br><span class="line">                &#125;  </span><br><span class="line">                // 撤销上一步所放置的皇后，即回溯  </span><br><span class="line">                rowExists[row] = a[row + column - 1] = b[queensNum + column - row] = false;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    // 测试  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">    	NQueensWithBacAlo queen = new NQueensWithBacAlo();  </span><br><span class="line">        queen.init();  </span><br><span class="line">        // 从第 1 列开始求解  </span><br><span class="line">        queen.testing(1);  </span><br><span class="line">       </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　其中八皇后问题的解法参考了：<a href="http://haolloyin.blog.51cto.com/1177454/353105/" target="_blank" rel="external">http://haolloyin.blog.51cto.com/1177454/353105/</a></p>
<p>　　该处有详细的解释。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　之前的课老师给我们讲了回溯法，回溯法从本质上来说并不能减低问题规模的量级，只是通过一定的约束条件减少了问题规模的常数项系数。回溯法的基本做法是搜索，它是一种可以避免不必要搜索的穷举式搜索法。&lt;/p&gt;
&lt;p&gt;　　回溯法是采用深度优先的思想进行遍历，而分枝限界法采用的是广度
    
    </summary>
    
      <category term="算法寻径" scheme="http://jrhu05.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BB%E5%BE%84/"/>
    
    
      <category term="回朔法" scheme="http://jrhu05.github.io/tags/%E5%9B%9E%E6%9C%94%E6%B3%95/"/>
    
      <category term="java" scheme="http://jrhu05.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>随机算法相关实例</title>
    <link href="http://jrhu05.github.io/post/random-algorithm.html"/>
    <id>http://jrhu05.github.io/post/random-algorithm.html</id>
    <published>2015-05-28T13:48:15.000Z</published>
    <updated>2015-06-02T12:10:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　上节课老师给我们讲解了随机算法，随机算法和贪心算法一样都是比较简单的算法。随机算法在分布式计算、通信、信息检索、计算几何、密码学等许多领域都有着广泛的应用，通常可分为两类Las Vegas算法和Monte Carlo算法。简单而言，LV算法通过多次求解来获得一个一定是正确的解，而MC算法通过多次求解来提高可信度，最终获得一接近于完全正确或者可信度可以接受（如99%或者更高的可能性是正确的）的近似解。</p>
<p>　　常见的实例有：找第k小元素的随机算法（Las Vegas算法）、Testing String Equality（Monte Carlo算法）、Pattern Matching（Monte Carlo算法）及其改进型（转为Las Vegas算法）、Random Sampling问题、主元素问题、素数测试问题、n后问题。</p>
<p>　　其中Random Sampling问题和主元素问题过于简单，所以没有实现，如果读者感兴趣可以自行实现，很简单。</p>
<p>　　下面进入正题，首先是找第k小元素的随机算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package random;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Las Vegas算法找第K小元素的java实现</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class FindTheKMin &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//int[] a=&#123;34,12,6,88,3,90,13,12,22,67,99,102,33,57&#125;;</span><br><span class="line">		List&lt;Integer&gt; a=new ArrayList&lt;Integer&gt;();</span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			a.add((int) (Math.random()*100));	</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		int index=(int) (Math.random()*9+1);</span><br><span class="line">		System.out.println(&quot;the &quot;+index+&quot; min is &quot;);</span><br><span class="line">		lasVegasFind(a,index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void lasVegasFind(List&lt;Integer&gt; a, int index) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		if (index&gt;a.size()||index&lt;0) &#123;</span><br><span class="line">			System.out.println(&quot;index out of boundary!&quot;);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			int random=(int) (Math.random()*a.size());</span><br><span class="line">			int mid=a.get(random);</span><br><span class="line">			List&lt;Integer&gt; s1=new ArrayList&lt;Integer&gt;();</span><br><span class="line">			List&lt;Integer&gt; s2=new ArrayList&lt;Integer&gt;();</span><br><span class="line">			List&lt;Integer&gt; s3=new ArrayList&lt;Integer&gt;();</span><br><span class="line">			for (Integer x : a) &#123;</span><br><span class="line">				if (x&lt;mid) &#123;</span><br><span class="line">					s1.add(x);</span><br><span class="line">				&#125;else if (x==mid) &#123;</span><br><span class="line">					s2.add(x);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					s3.add(x);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (s1.size()&gt;=index) &#123;</span><br><span class="line">				lasVegasFind(s1, index);</span><br><span class="line">			&#125;else if (s1.size()+s2.size()&gt;=index) &#123;</span><br><span class="line">				System.out.println(mid);</span><br><span class="line">				return;</span><br><span class="line">			&#125;else if (s1.size()+s2.size()&lt;index) &#123;</span><br><span class="line">				lasVegasFind(s3, index-s1.size()-s2.size());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　接着是Testing String Equality（Monte Carlo算法），问题的基本描述贴在代码里了，其中我用01二进制序列来近似替代字符序列，其实二者原理层面都是一样的，用来理解算法的基本原理没有任何问题。其中所用到的模二除法是源自CRC校验那篇文章，感兴趣的可以戳<a href="/post/crc4-java.html" title="模2除法相关原理与实现">这里</a>查看具体的算法流程。由于下一个Pattern Matching问题可以直接调用Testing String Equality中的实现类，所以所有的相关类全部用public属性，方便调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">package random;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Monte Carlo算法长字符串匹配的实现</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestingStringEquality &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 问题描述</span><br><span class="line">		设A处有一个长字符串x（e.g. 长度为10^6 ），</span><br><span class="line">		B处也有一个长字符串y，A将x发给B，由</span><br><span class="line">		B判断是否有x=y</span><br><span class="line">	 */</span><br><span class="line">	static int M=11483;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] byteA=randomByteGen();</span><br><span class="line">		int[] byteB=randomByteGen();</span><br><span class="line">		//System.out.println(Arrays.toString(byteA));</span><br><span class="line">		System.out.println(byteA.length);</span><br><span class="line">		System.out.println(byteB.length);</span><br><span class="line">		long mccStart=System.currentTimeMillis();</span><br><span class="line">		boolean isEqual=monteCarloCheck(byteA,byteA);</span><br><span class="line">		long mccEnd=System.currentTimeMillis();</span><br><span class="line">		boolean isEqual2=normalCheck(byteA,byteA);</span><br><span class="line">		long ncEnd=System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;byteA equals to byteB?: &quot;+isEqual);</span><br><span class="line">		System.out.println(&quot;the time cost of monteCarloCheck is: &quot;+(mccEnd-mccStart)+&quot;ms&quot;);</span><br><span class="line">		System.out.println(&quot;the time cost of normalCheck is: &quot;+(ncEnd-mccEnd)+&quot;ms&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 普通检测法</span><br><span class="line">	 * @param byteA</span><br><span class="line">	 * @param byteB</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static boolean normalCheck(int[] byteA, int[] byteB) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		if (byteA.length!=byteB.length) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			for (int i = 0; i &lt; byteA.length; i++) &#123;</span><br><span class="line">				if (byteA[i]!=byteB[i]) &#123;</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 指纹检测法</span><br><span class="line">	 * @param byteA</span><br><span class="line">	 * @param byteB</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static boolean monteCarloCheck(int[] byteA, int[] byteB) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		int[] mBytes=m2Binary();</span><br><span class="line">		if (byteA.length!=byteB.length) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			int[] fingerPrintA=mod2Div(byteA, mBytes);</span><br><span class="line">			int[] fingerPrintB=mod2Div(byteB, mBytes);</span><br><span class="line">			for (int i = 0; i &lt; fingerPrintA.length; i++) &#123;</span><br><span class="line">				if (fingerPrintA[i]!=fingerPrintB[i]) &#123;</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 将取指纹用到的M转换成二进制01数组</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static int[] m2Binary()&#123;</span><br><span class="line">		String mString=Integer.toBinaryString(M);</span><br><span class="line">		String[] mStrings=mString.split(&quot;&quot;);</span><br><span class="line">		int[] mBytes=new int[mStrings.length];</span><br><span class="line">		for (int i = 0; i &lt; mBytes.length; i++) &#123;</span><br><span class="line">			mBytes[i]=Integer.valueOf(mStrings[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(mBytes));</span><br><span class="line">		return mBytes;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 随机生成长度在1000000以内的01比特数组</span><br><span class="line">	 * @return 01比特数组</span><br><span class="line">	 */</span><br><span class="line">	public static int[] randomByteGen() &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		int length=(int) (Math.random()*1000000);</span><br><span class="line">		//int length=10000000;</span><br><span class="line">		int[] gen=new int[length];</span><br><span class="line">		for (int i = 0; i &lt; gen.length; i++) &#123;</span><br><span class="line">			double flag=Math.random();</span><br><span class="line">			if (flag&gt;0.5) &#123;</span><br><span class="line">				gen[i]=1;</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				gen[i]=0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return gen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 模二除法求余数</span><br><span class="line">	 * @param newInfo 被除数</span><br><span class="line">	 * @param genarete 除数</span><br><span class="line">	 * @return 余数</span><br><span class="line">	 */</span><br><span class="line">	public static int[] mod2Div(int[] newInfo, int[] genarete) &#123;</span><br><span class="line">		//将生成多项式的最高位去掉，因为最高位经过xor肯定出0所以不用考虑</span><br><span class="line">		int[] newGen=new int[genarete.length-1];</span><br><span class="line">		for (int i = 0; i &lt; newGen.length; i++) &#123;</span><br><span class="line">			newGen[i]=genarete[i+1];</span><br><span class="line">		&#125;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		int flag=newInfo[0];</span><br><span class="line">		//余数存储矩阵初始化</span><br><span class="line">		int[] temp=new int[newGen.length];</span><br><span class="line">		int lastIndex=temp.length-1;</span><br><span class="line">		for (int i = 0; i &lt; temp.length; i++) &#123;</span><br><span class="line">			temp[i]=newInfo[i+1];</span><br><span class="line">		&#125;</span><br><span class="line">		//初始化计数器</span><br><span class="line">		int count=temp.length+1;</span><br><span class="line">		//进行窗口推进式xor运算</span><br><span class="line">		while (count&lt;=newInfo.length) &#123;</span><br><span class="line">			if (flag==1) &#123;</span><br><span class="line">				temp=xorGroup(temp, newGen);</span><br><span class="line">			&#125;</span><br><span class="line">			//标记位为temp的高位，如果为1则表示下一次运算结果可也上1，否则只能上0</span><br><span class="line">			if (count&lt;newInfo.length) &#123;</span><br><span class="line">				flag=temp[0];</span><br><span class="line">				//temp运算窗口移动一位，同时计数器自加</span><br><span class="line">				for (int i = 0; i &lt;temp.length-1; i++) &#123;</span><br><span class="line">					temp[i]=temp[i+1];</span><br><span class="line">				&#125;</span><br><span class="line">				temp[lastIndex]=newInfo[count];</span><br><span class="line">			&#125;</span><br><span class="line">			count++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">//		System.out.println(&quot;模二运算计算出的余数：&quot;);</span><br><span class="line">//		System.out.println(Arrays.toString(temp));</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 对两个二进制序列进行异或运算</span><br><span class="line">	 * @param a 待计算序列1</span><br><span class="line">	 * @param b 待计算序列2</span><br><span class="line">	 * @return 异或运算结果</span><br><span class="line">	 */</span><br><span class="line">	public static int[] xorGroup(int[] a,int[] b)&#123;</span><br><span class="line">		int[] result=new int[a.length];</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			result[i]=xor(a[i],b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 对两个二进制位进行异或运算</span><br><span class="line">	 * @param i 待计算二进制位1</span><br><span class="line">	 * @param j 待计算二进制位2</span><br><span class="line">	 * @return 异或运算结果</span><br><span class="line">	 */</span><br><span class="line">	public static int xor(int i, int j) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		if (i==j) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在实际运行的时候，发现随机算法较之于直接比较的算法没有取得优势，反而有较大的损耗，这与理论预计不符，思考后觉得原因应该是出在我取指纹（即模二除法）部分代码不够优化，执行效率低所致，故以上代码仅供理解算法原理之用。</p>
<p>　　附运行结果截图：</p>
<p><img src="/img/random-algorithm/result1.jpg" alt=""></p>
<p>　　最后是Pattern Matching，字符串匹配，我直接实现了它的改进型，转成了Las Vegas算法。其实两者没有太大区别，只是在进行指纹匹配发现为true后不直接返回，进行一一匹配，即保证100%两子串完全相同时才返回为真，这样就变成无需多次运行来提高正确概率，一次运行即可确切的给出是否有子串匹配，即算法出错的概率为0。</p>
<p>　　具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package random;</span><br><span class="line">/**</span><br><span class="line"> * LasVegas算法实现字符串匹配</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class PatternMatching &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 问题描述</span><br><span class="line">		给定两个字符串：X=x 1 ,…,x n ，Y=y 1 ,…,y m ，</span><br><span class="line">		看Y是否为X的子串？（即Y是否为X中的一段）</span><br><span class="line">	 * </span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//包含Y的字符串</span><br><span class="line">//		int[] X=&#123;1,0,1,0,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,</span><br><span class="line">//				0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,</span><br><span class="line">//				0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,</span><br><span class="line">//				1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,</span><br><span class="line">//				0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,</span><br><span class="line">//				0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,</span><br><span class="line">//				0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,1,1&#125;;</span><br><span class="line">		//不包含Y的字符串 供测试使用</span><br><span class="line">		int[] X=&#123;1,0,1,0,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,</span><br><span class="line">				0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,</span><br><span class="line">				0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,</span><br><span class="line">				1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,</span><br><span class="line">				0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,</span><br><span class="line">				0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,</span><br><span class="line">				0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,1,1&#125;;</span><br><span class="line">		int[] Y=&#123;1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,</span><br><span class="line">				0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,</span><br><span class="line">				1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,</span><br><span class="line">				1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,</span><br><span class="line">				1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,</span><br><span class="line">				1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0,&#125;;</span><br><span class="line">		boolean isContain=lasVegPatMatch(X,Y);</span><br><span class="line">		System.out.println(isContain);</span><br><span class="line">	&#125;</span><br><span class="line">	private static boolean lasVegPatMatch(int[] x, int[] y) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		for (int i = 0; i &lt; x.length-y.length; i++) &#123;</span><br><span class="line">			int[] subX=new int[y.length];</span><br><span class="line">			for (int j = 0; j &lt; subX.length; j++) &#123;</span><br><span class="line">				subX[j]=x[i+j];</span><br><span class="line">			&#125;</span><br><span class="line">			boolean isEqual=TestingStringEquality.monteCarloCheck(subX, y);</span><br><span class="line">			if (isEqual) &#123;</span><br><span class="line">				boolean isAbsEqual=TestingStringEquality.normalCheck(subX, y);</span><br><span class="line">				if (isAbsEqual) &#123;</span><br><span class="line">					System.out.println(&quot;sub is from: &quot;+i);</span><br><span class="line">					return true;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					return true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　<del>明天的课要讲素数测试问题和N皇后问题，bravo！好高大上的样子。</del></p>
<p>　　补完素数测试和N后问题。</p>
<p>　　素数测试问题：</p>
<p>　　PPT里给出的迭代方式求解的方法实在看不懂，所以我又照着概念自己写了个非递归的，2333。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package random;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Monte Carlo算法+二次探测实现素数测试</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class PrimeCheck &#123;</span><br><span class="line">	static boolean composite;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//int n=61237;</span><br><span class="line">		//int n=17;</span><br><span class="line">		int n=561;//561是一个典型的Carmichael数，故用之来测试</span><br><span class="line">		System.out.println(n+&quot; is prime?:&quot;+prim(n));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static boolean prim(int n) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		int a,result;</span><br><span class="line">		composite=false;</span><br><span class="line">		a=(int) (Math.random()*(n-3)+2);//随机取底数a，随机性体现的地方</span><br><span class="line">		//result=power(a,n-1,n);</span><br><span class="line">		result=powerNoRec(a,n-1,n);</span><br><span class="line">		if (composite||(result!=1)) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;else return true;</span><br><span class="line">		</span><br><span class="line">//		if (result!=1) &#123;</span><br><span class="line">//			//如果没有二次探测，那么对于这个问题false是百分之百正确的</span><br><span class="line">//			//即回答是合数</span><br><span class="line">//			return false;</span><br><span class="line">//		&#125;else &#123;</span><br><span class="line">//			//而true是有可能错误的</span><br><span class="line">//			return true;</span><br><span class="line">//		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int powerNoRec(int a, int i, int n) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		//我自己实现的非递归方法</span><br><span class="line">		int result=(int) (Math.pow(a, i)%n);</span><br><span class="line">		if (n&lt;2) &#123;</span><br><span class="line">			composite=false;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			for (int j = 2; j &lt; n-1; j++) &#123;</span><br><span class="line">				if ((j*j)%n==1) &#123;</span><br><span class="line">					composite=true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int power(int a, int p, int n) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		//ppt中用递归来进行实现的方法</span><br><span class="line">		//计算a^p mod n,并实施对n的二次探测</span><br><span class="line">		int x,result;</span><br><span class="line">		if (p==0) &#123;</span><br><span class="line">			result=1;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			x=power(a, p/2, n);//递归计算</span><br><span class="line">			result=(x*x)%n;//二次探测</span><br><span class="line">			if ((result==1)&amp;&amp;(x!=1)&amp;&amp;(x!=(n-1))) &#123;</span><br><span class="line">				//即表示则方程x^2 ≡ 1(mod p)</span><br><span class="line">				//的解不为x=1，p-1</span><br><span class="line">				//即二次探测失败</span><br><span class="line">				composite=true;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			if ((p%2)==1) &#123;//p是奇数</span><br><span class="line">				 result=(result*a)%n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　N后问题：相当有名的问题，我用随机算法没有求解出结果，最高只能求到7，后面的死活凑不出最后一位来，也难怪8^8=16 777 216其中只有96中情况符合要求，概率小的可怜，百万分之几的概率。</p>
<p>　　不过思路是没问题的，下面的回溯法应该有确定性的解法，到时候在看吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">package random;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用随机算法解决N后问题</span><br><span class="line"> * 以八皇后问题为例</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class NQueens &#123;</span><br><span class="line">	private static int[][] map=new int[8][8];</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//地图初始化，0表示空，1表示皇后在这个位置上</span><br><span class="line">		for (int i = 0; i &lt; map.length; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; map[i].length; j++) &#123;</span><br><span class="line">				 map[i][j]=0;		</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">//这部分是求解正确答案的循环，有兴趣的可以取消注释跑一下玩//玩，反正我跑了几分钟也没出结果，2333</span><br><span class="line">//		int count=0;</span><br><span class="line">//		while (count&lt;8) &#123;</span><br><span class="line">//			count=0;</span><br><span class="line">//			eightQueen();</span><br><span class="line">//			for (int i = 0; i &lt; map.length; i++) &#123;</span><br><span class="line">//				for (int j = 0; j &lt; map[i].length; j++) &#123;</span><br><span class="line">//					if (map[i][j]==1) &#123;</span><br><span class="line">//						count++;</span><br><span class="line">//					&#125; 		</span><br><span class="line">//				&#125;	</span><br><span class="line">//			&#125;</span><br><span class="line">//			System.out.println(count);</span><br><span class="line">//		&#125;</span><br><span class="line">		eightQueen();</span><br><span class="line">		for (int i = 0; i &lt; map.length; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; map[i].length; j++) &#123;</span><br><span class="line">				 System.out.print(map[i][j]+&quot; &quot;);		</span><br><span class="line">			&#125;	</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	private static void eightQueen() &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		for (int i = 0; i &lt; map.length; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; map[i].length; j++) &#123;</span><br><span class="line">				 map[i][j]=0;		</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = 0; i &lt; map.length; i++) &#123;</span><br><span class="line">			boolean stopFlag=false;</span><br><span class="line">			int count=0;</span><br><span class="line">			while (!stopFlag) &#123;</span><br><span class="line">				int localtion=(int) (Math.random()*7);//随机产生皇后位置</span><br><span class="line">				if (count&gt;=100000) &#123;</span><br><span class="line">					//超时，未找到完整解时返回</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				if (i==0) &#123;</span><br><span class="line">					map[i][localtion]=1;//第一行直接摆，无需检测冲突</span><br><span class="line">					stopFlag=true;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					if (!checkCollision(i,localtion)) &#123;</span><br><span class="line">						map[i][localtion]=1;//如果没有检测到冲突</span><br><span class="line">						stopFlag=true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 冲突检测，检测要摆的皇后为位置和上面已经摆好的所有皇后的位置是否有冲突</span><br><span class="line">	 * @param i 准备摆的皇后的行</span><br><span class="line">	 * @param localtion 准备摆的皇后的列</span><br><span class="line">	 * @return 是否有冲突</span><br><span class="line">	 */</span><br><span class="line">	private static boolean checkCollision(int i, int localtion) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		boolean collison=false;</span><br><span class="line">		List&lt;Integer[]&gt; resultList=new ArrayList&lt;Integer[]&gt;();</span><br><span class="line">		for (int j = 0; j &lt; map.length; j++) &#123;</span><br><span class="line">			for (int j2 = 0; j2 &lt; map[j].length; j2++) &#123;</span><br><span class="line">				if (map[j][j2]==1) &#123;</span><br><span class="line">					resultList.add(new Integer[]&#123;j,j2&#125;);</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for (Integer[] integers : resultList) &#123;</span><br><span class="line">			int locRow=integers[0];//已摆好的queen的行</span><br><span class="line">			int locCol= integers[1];//已摆好的queen的列</span><br><span class="line">			int unLocRow=i;//未摆好的queen的行</span><br><span class="line">			int unLocCol=localtion;//未摆好的queen的列</span><br><span class="line">			if (unLocCol==locCol ||</span><br><span class="line">					(locRow-unLocRow)==(locCol-unLocCol)||(locRow-unLocRow)==-(locCol-unLocCol)) &#123;</span><br><span class="line">				collison=true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		return collison;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果示意图：<br><img src="/img/random-algorithm/result2.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　上节课老师给我们讲解了随机算法，随机算法和贪心算法一样都是比较简单的算法。随机算法在分布式计算、通信、信息检索、计算几何、密码学等许多领域都有着广泛的应用，通常可分为两类Las Vegas算法和Monte Carlo算法。简单而言，LV算法通过多次求解来获得一个一定是正
    
    </summary>
    
      <category term="算法寻径" scheme="http://jrhu05.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BB%E5%BE%84/"/>
    
    
      <category term="随机算法" scheme="http://jrhu05.github.io/tags/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CRC4的java实现</title>
    <link href="http://jrhu05.github.io/post/crc4-java.html"/>
    <id>http://jrhu05.github.io/post/crc4-java.html</id>
    <published>2015-05-26T09:21:08.000Z</published>
    <updated>2015-05-26T10:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近学通信网的时候，方老师给我们布置了两个作业，分别是hamming编码译码和CRC校验模拟。Hamming编译码以前写过一个<a href="/post/hamming-simulator.html" title="hamming(7,4)模拟器">hamming（7,4）的模拟器</a>，所以直接copy了以前的。额外写了个CRC校验的，由于太懒，所以直接CRC4，其实原理都差不多。</p>
<p>　　最核心的就是如何实现模二除法运算，关于这部分参考了这篇文章的思路：课程设计报告–用模2除法计算CRC码的CRC校验软件设计（<a href="http://www.docin.com/p-716983519.html" title="模2除法原理" target="_blank" rel="external">http://www.docin.com/p-716983519.html</a>）</p>
<p>　　摘录其中核心部分如下：</p>
<p><img src="/img/crc4-java/mod2Part1.png" alt=""></p>
<p><img src="/img/crc4-java/mod2Part2.png" alt=""></p>
<p><img src="/img/crc4-java/mod2Part3.png" alt=""></p>
<p><strong>I. 题目：</strong></p>
<p>　　以ppt中的例题为例</p>
<p>　　信息多项式为：x7+x5+1，生成多项式为：x3+1，问：实际传输的比特串为什么？</p>
<p>　　解答：x7+x5+1=10100001；x3+1=1001</p>
<p>　　余数为：x2+x+1＝111</p>
<p>　　实际传输的比特串为：10100001111</p>
<p><strong>II. 主程序：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">package crc;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">/**</span><br><span class="line"> * CRC编译码模拟试验</span><br><span class="line"> * 以ppt中的CRC4为例，其余的CRC8或CRC16之类的基本类似，稍作改动即可</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class CRC4 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] information=&#123;1,0,1,0,0,0,0,1&#125;;</span><br><span class="line">		int[] genarete=&#123;1,0,0,1&#125;;</span><br><span class="line">		System.out.println(&quot;待编译的二进制序列是：&quot;+Arrays.toString(information));</span><br><span class="line">		System.out.println(&quot;生成多项式是：&quot;+Arrays.toString(genarete));</span><br><span class="line">		System.out.println(&quot;————进行编译操作————&quot;);</span><br><span class="line">		int[] encode=crcEncode(genarete,information);</span><br><span class="line">		System.out.println(&quot;编译好的二进制序列是：&quot;);</span><br><span class="line">		System.out.println(Arrays.toString(encode));</span><br><span class="line">		System.out.println(&quot;————下面进行CRC4的校验测试————&quot;);</span><br><span class="line">		System.out.println(&quot;假设传过来的序列发生了一位错误，错误后的编码是：&quot;);</span><br><span class="line">		int[] wrong=randomWrong(encode);</span><br><span class="line">		System.out.println(Arrays.toString(wrong));</span><br><span class="line">		System.out.println(&quot;根据生成多项式1001来进行检查&quot;);</span><br><span class="line">		int[] remainCheck=mod2Div(wrong, genarete);</span><br><span class="line">		boolean isRight=notContainZero(remainCheck);</span><br><span class="line">		if (isRight) &#123;</span><br><span class="line">			System.out.println(&quot;由于检测余数 &quot;+Arrays.toString(remainCheck)+&quot;是全0的，故该序列是没有错误的&quot;);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			System.out.println(&quot;由于检测余数 &quot;+Arrays.toString(remainCheck)+&quot;不是全0的，故该序列是发生错误的&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 *  检测一二进制序列是否完全为0</span><br><span class="line">	 * @param remainCheck 待检测序列</span><br><span class="line">	 * @return 是否全为0</span><br><span class="line">	 */</span><br><span class="line">	private static boolean notContainZero(int[] remainCheck) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		for (int i = 0; i &lt; remainCheck.length; i++) &#123;</span><br><span class="line">			if (remainCheck[i]==1) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 编码</span><br><span class="line">	 * @param genarete 生成多项式</span><br><span class="line">	 * @param information 信息多形式</span><br><span class="line">	 * @return 编码后的二进制序列</span><br><span class="line">	 */</span><br><span class="line">	private static int[] crcEncode(int[] genarete,int[] information) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		//将信息码抬高n位，n为生成多项式的最高项次数</span><br><span class="line">		int up=genarete.length-1;</span><br><span class="line">		int[] newInfo=new int[information.length+up];</span><br><span class="line">		for (int i = 0; i &lt; information.length; i++) &#123;</span><br><span class="line">			newInfo[i]=information[i];</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = information.length; i &lt; newInfo.length; i++) &#123;</span><br><span class="line">			newInfo[i]=0;</span><br><span class="line">		&#125;</span><br><span class="line">		//进行模二除法</span><br><span class="line">		int[] remain=mod2Div(newInfo,genarete); </span><br><span class="line">        //进行余数和源信息的拼接生成最后的编码</span><br><span class="line">		int starIndex=information.length;</span><br><span class="line">		for (int i = 0; i &lt; remain.length; i++) &#123;</span><br><span class="line">			newInfo[starIndex+i]=remain[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return newInfo;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 模二除法求余数</span><br><span class="line">	 * @param newInfo 被除数</span><br><span class="line">	 * @param newGen 除数</span><br><span class="line">	 * @return 余数</span><br><span class="line">	 */</span><br><span class="line">	private static int[] mod2Div(int[] newInfo, int[] genarete) &#123;</span><br><span class="line">		//将生成多项式的最高位去掉，因为最高位经过xor肯定出0所以不用考虑</span><br><span class="line">		int[] newGen=new int[genarete.length-1];</span><br><span class="line">		for (int i = 0; i &lt; newGen.length; i++) &#123;</span><br><span class="line">			newGen[i]=genarete[i+1];</span><br><span class="line">		&#125;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		int flag=newInfo[0];</span><br><span class="line">		//余数存储矩阵初始化</span><br><span class="line">		int[] temp=new int[newGen.length];</span><br><span class="line">		int lastIndex=temp.length-1;</span><br><span class="line">		for (int i = 0; i &lt; temp.length; i++) &#123;</span><br><span class="line">			temp[i]=newInfo[i+1];</span><br><span class="line">		&#125;</span><br><span class="line">		//初始化计数器</span><br><span class="line">		int count=temp.length+1;</span><br><span class="line">		//进行窗口推进式xor运算</span><br><span class="line">		while (count&lt;=newInfo.length) &#123;</span><br><span class="line">			if (flag==1) &#123;</span><br><span class="line">				temp=xorGroup(temp, newGen);</span><br><span class="line">			&#125;</span><br><span class="line">			//标记位为temp的高位，如果为1则表示下一次运算结果可也上1，否则只能上0</span><br><span class="line">			if (count&lt;newInfo.length) &#123;</span><br><span class="line">				flag=temp[0];</span><br><span class="line">				//temp运算窗口移动一位，同时计数器自加</span><br><span class="line">				for (int i = 0; i &lt;temp.length-1; i++) &#123;</span><br><span class="line">					temp[i]=temp[i+1];</span><br><span class="line">				&#125;</span><br><span class="line">				temp[lastIndex]=newInfo[count];</span><br><span class="line">			&#125;</span><br><span class="line">			count++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;模二运算计算出的余数：&quot;);</span><br><span class="line">		System.out.println(Arrays.toString(temp));</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 对两个二进制序列进行异或运算</span><br><span class="line">	 * @param a 待计算序列1</span><br><span class="line">	 * @param b 待计算序列2</span><br><span class="line">	 * @return 异或运算结果</span><br><span class="line">	 */</span><br><span class="line">	private static int[] xorGroup(int[] a,int[] b)&#123;</span><br><span class="line">		int[] result=new int[a.length];</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			result[i]=xor(a[i],b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 对两个二进制位进行异或运算</span><br><span class="line">	 * @param i 待计算二进制位1</span><br><span class="line">	 * @param j 待计算二进制位2</span><br><span class="line">	 * @return 异或运算结果</span><br><span class="line">	 */</span><br><span class="line">	private static int xor(int i, int j) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		if (i==j) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 随机生成一位错误</span><br><span class="line">	 * @param encode 待错比特串</span><br><span class="line">	 * @return 有一位错误的比特串</span><br><span class="line">	 */</span><br><span class="line">	private static int[] randomWrong(int[] encode) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		</span><br><span class="line">		int wrongIndex=(int) (Math.random()*encode.length);</span><br><span class="line">		int[] wrong=encode;</span><br><span class="line">		//对错误位进行取反</span><br><span class="line">		if (wrong[wrongIndex]==0) &#123;</span><br><span class="line">			wrong[wrongIndex]=1;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			wrong[wrongIndex]=0;</span><br><span class="line">		&#125;</span><br><span class="line">		return wrong;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>III. 实验结果截图：</strong><br><img src="/img/crc4-java/result.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　最近学通信网的时候，方老师给我们布置了两个作业，分别是hamming编码译码和CRC校验模拟。Hamming编译码以前写过一个&lt;a href=&quot;/post/hamming-simulator.html&quot; title=&quot;hamming(7,4)模拟器&quot;&gt;hamming（7
    
    </summary>
    
      <category term="研究僧呀" scheme="http://jrhu05.github.io/categories/%E7%A0%94%E7%A9%B6%E5%83%A7%E5%91%80/"/>
    
    
      <category term="crc" scheme="http://jrhu05.github.io/tags/crc/"/>
    
      <category term="模2除法" scheme="http://jrhu05.github.io/tags/%E6%A8%A12%E9%99%A4%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法的相关实例</title>
    <link href="http://jrhu05.github.io/post/greedy-algorithm.html"/>
    <id>http://jrhu05.github.io/post/greedy-algorithm.html</id>
    <published>2015-05-22T13:49:47.000Z</published>
    <updated>2015-05-28T09:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　上次课老师讲了贪心算法，贪心算法的基本思路很简单，最接近没有学习算法的人的一般思维模式，因而也最好理解，核心的思路是总是作出当前看来最好的选择。</p>
<p>　　可用贪心算法解决的经典问题有：活动安排问题、Dijkstra算法、Prim算法、Kruskal算法、Haffman编码等。</p>
<p>　　活动安排问题的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package greedyAlgorithm;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 活动安排问题的贪心算法求解</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ActivityArrangement &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] start=&#123;1,3,0,5,3,5,6,8,8,2,12&#125;;</span><br><span class="line">		int[] end=&#123;4,5,6,7,8,9,10,11,12,13,14&#125;;</span><br><span class="line">		int[] arrangement=greedyArrangement(start,end);</span><br><span class="line">		System.out.println(&quot;the arrangement is:&quot;+Arrays.toString(arrangement));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static int[] greedyArrangement(int[] s,int[] e) &#123;</span><br><span class="line">		int total=s.length;</span><br><span class="line">		int endFlag=e[0];</span><br><span class="line">		int[] arrangement=new int[total];</span><br><span class="line">		arrangement[0]=1;</span><br><span class="line">		int arrangeCount=1;</span><br><span class="line">		for (int i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">			if(s[i]&gt;endFlag)&#123;</span><br><span class="line">				arrangement[arrangeCount]=i+1;</span><br><span class="line">				arrangeCount+=1;</span><br><span class="line">				endFlag=e[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return arrangement;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　Dijkstra算法是经典的求单源点最短路径的算法，其java实现如下（用邻接矩阵来表示有向图）：</p>
<p>　　本例中的有向图如下：</p>
<p><img src="/img/greedy-algorithm/problem1.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package greedyAlgorithm;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line">/**</span><br><span class="line"> * 单源点最短路径Dijkstra算法实现</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Dijkstra &#123;</span><br><span class="line">	private static int maxD=Integer.MAX_VALUE;</span><br><span class="line">	private static int minD=0;</span><br><span class="line">	private static HashMap&lt;Integer, Integer&gt; distanceMap;</span><br><span class="line">	private static Set&lt;Integer&gt; findedSet;</span><br><span class="line">	private static int[] pre;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[][] matrix=&#123;&#123;maxD,10,maxD,30,100&#125;,</span><br><span class="line">						&#123;maxD,maxD,50,maxD,maxD&#125;,</span><br><span class="line">						&#123;maxD,maxD,maxD,maxD,10&#125;,</span><br><span class="line">						&#123;maxD,maxD,20,maxD,60&#125;,</span><br><span class="line">						&#123;maxD,maxD,maxD,maxD,maxD&#125;&#125;;</span><br><span class="line">		int start=1;//从哪一个点开始找</span><br><span class="line">		dijkstraFind(matrix, start-1);</span><br><span class="line">		for (int i = 0; i &lt; pre.length; i++) &#123;</span><br><span class="line">			pre[i]+=1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(Entry&lt;Integer, Integer&gt; entry:distanceMap.entrySet())&#123; </span><br><span class="line">			if (entry.getKey()!=start-1) &#123;</span><br><span class="line">				 System.out.println(&quot;start to &quot;+(entry.getKey()+1)+&quot; dis &quot;+entry.getValue());</span><br><span class="line">				 System.out.print(&quot;path:&quot;+(entry.getKey()+1));</span><br><span class="line">				 printPath(pre, entry.getKey());</span><br><span class="line">				 System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">       &#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void printPath(int[] pre,int i) &#123;</span><br><span class="line">		if(pre[i]!=0) &#123;</span><br><span class="line">			System.out.print(&quot;--&gt;&quot;+(pre[i]));</span><br><span class="line">			printPath(pre, pre[i]-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static Map&lt;Integer, Integer&gt; dijkstraFind(int[][] matrix,int start) &#123;</span><br><span class="line">		pre=new int[matrix.length];</span><br><span class="line">		pre[start]=-1;</span><br><span class="line">		// 用来存放起始点到其它点当前的距离  </span><br><span class="line">	    distanceMap = new HashMap&lt;Integer, Integer&gt;();  </span><br><span class="line">	    // 用来存放已经找到最短路径的点的集合  </span><br><span class="line">	    findedSet = new HashSet&lt;Integer&gt;();  </span><br><span class="line">	    findedSet.add(start);</span><br><span class="line">	    // 用start相邻的点初始化distanceMap  </span><br><span class="line">        for (int i = 0; i &lt; matrix.length; i++) &#123;   </span><br><span class="line">                distanceMap.put(i, matrix[start][i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">//        for(Entry&lt;Integer, Integer&gt; entry:distanceMap.entrySet())&#123;    </span><br><span class="line">//            System.out.println(entry.getKey()+&quot;---&gt;&quot;+entry.getValue());    </span><br><span class="line">//       &#125;</span><br><span class="line">        while (findedSet.size() != matrix.length) &#123;  </span><br><span class="line">            int currentMinIndex = currentMinIndex();  </span><br><span class="line">            // 用此结点更新其它结点的距离  </span><br><span class="line">            for (int i = 0; i &lt; matrix.length; i++) &#123;  </span><br><span class="line">                if (!findedSet.contains(i) &amp;&amp; matrix[currentMinIndex][i] != maxD  </span><br><span class="line">                        &amp;&amp; matrix[currentMinIndex][i] + distanceMap.get(currentMinIndex) &lt; distanceMap.get(i))  </span><br><span class="line">                &#123; distanceMap.put(i, matrix[currentMinIndex][i] + distanceMap.get(currentMinIndex));</span><br><span class="line">                pre[i]=currentMinIndex;&#125;</span><br><span class="line">            &#125;  </span><br><span class="line">            // 放入findedset  </span><br><span class="line">            findedSet.add(currentMinIndex); </span><br><span class="line">        &#125;  </span><br><span class="line">		return distanceMap;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 返回当前最小距离的点(必须不包含在findedSet中) </span><br><span class="line">	private static int currentMinIndex() &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; it = distanceMap.entrySet().iterator();  </span><br><span class="line">        int min = Integer.MAX_VALUE;  </span><br><span class="line">        int minIndex = -1;  </span><br><span class="line">        while (it.hasNext()) &#123;  </span><br><span class="line">            Entry&lt;Integer, Integer&gt; entry = it.next();  </span><br><span class="line">            if (!findedSet.contains(entry.getKey()) &amp;&amp; entry.getValue() &lt; min) &#123;  </span><br><span class="line">                min = entry.getValue();  </span><br><span class="line">                minIndex = entry.getKey();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return minIndex;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　输出如下：</p>
<p><img src="/img/greedy-algorithm/resultOfDijkstra.png" alt=""></p>
<p>　　Prim算法和Kruskal算法都是为了解决无向图最小生成树问题所设计的算法，所以该部分实例用同一个无向图来进行计算，还是用邻接矩阵来表示该无向图。</p>
<p>　　该无向图如下：</p>
<p><img src="/img/greedy-algorithm/problem2.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Prim算法实现：</span><br><span class="line">package greedyAlgorithm;</span><br><span class="line">/**</span><br><span class="line"> * prim算法的java实现</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Prim &#123;</span><br><span class="line">	static int MAX = Integer.MAX_VALUE;   </span><br><span class="line">	</span><br><span class="line">	 public static void main(String[] args) &#123;</span><br><span class="line">         int[][] map = new int[][]&#123;</span><br><span class="line">         &#123;MAX,6,1,5,MAX,MAX&#125;,</span><br><span class="line">         &#123;6,MAX,5,MAX,3,MAX&#125;,</span><br><span class="line">         &#123;1,5,MAX,5,6,4&#125;,</span><br><span class="line">         &#123;5,MAX,5,MAX,MAX,2&#125;,</span><br><span class="line">         &#123;MAX,3,6,MAX,MAX,6&#125;,</span><br><span class="line">         &#123;MAX,MAX,4,2,6,MAX&#125;,</span><br><span class="line">		 &#125;;</span><br><span class="line">		 prim(map, map.length);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">    public static void prim(int[][] graph, int n)&#123;</span><br><span class="line">        </span><br><span class="line">        char[] c = new char[]&#123;&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;&#125;;        </span><br><span class="line">        int[] lowcost = new int[n];       </span><br><span class="line">        int[] mst = new int[n];</span><br><span class="line">        int i, j, min, minid, sum = 0;</span><br><span class="line">        </span><br><span class="line">        for(i = 1; i &lt; n; i++)&#123;</span><br><span class="line">            lowcost[i] = graph[0][i];</span><br><span class="line">            mst[i] = 0;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(i = 1; i &lt; n; i++)&#123;</span><br><span class="line">            min = MAX;</span><br><span class="line">            minid = 0;</span><br><span class="line">            //找出代价最小的那个点</span><br><span class="line">            for(j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                if (lowcost[j] &lt; min &amp;&amp; lowcost[j] != 0) &#123;</span><br><span class="line">                    min = lowcost[j];</span><br><span class="line">                    minid = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(c[mst[minid]] + &quot;to&quot; + c[minid] + &quot; value：&quot; + min);</span><br><span class="line">            </span><br><span class="line">            sum += min;</span><br><span class="line">            lowcost[minid] = 0;</span><br><span class="line">            //将上一次计算后得到点的邻接边的权值赋给 lowcost[]      </span><br><span class="line">            for (j = 1; j &lt; n; j++) &#123;    </span><br><span class="line">                if (graph[minid][j] &lt; lowcost[j]) &#123;</span><br><span class="line">                    lowcost[j] = graph[minid][j];</span><br><span class="line">                    mst[j] = minid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;sum:&quot; + sum);</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　Prim算法结果：</p>
<p><img src="/img/greedy-algorithm/resultOfprim.png" alt=""></p>
<p>　　kruskal算法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package greedyAlgorithm;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * kruskal算法的java实现</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Kruskal &#123;</span><br><span class="line">	static int MAX = Integer.MAX_VALUE; </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		 int[][] map = new int[][]&#123;</span><br><span class="line">		         &#123;MAX,6,1,5,MAX,MAX&#125;,</span><br><span class="line">		         &#123;6,MAX,5,MAX,3,MAX&#125;,</span><br><span class="line">		         &#123;1,5,MAX,5,6,4&#125;,</span><br><span class="line">		         &#123;5,MAX,5,MAX,MAX,2&#125;,</span><br><span class="line">		         &#123;MAX,3,6,MAX,MAX,6&#125;,</span><br><span class="line">		         &#123;MAX,MAX,4,2,6,MAX&#125;,</span><br><span class="line">				 &#125;;</span><br><span class="line">		 kruskal(map, map.length);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void kruskal(int[][] map, int length) &#123;</span><br><span class="line">		 //顶点个数</span><br><span class="line">        int num = length;</span><br><span class="line">        //存放对应顶点所在连通图标识</span><br><span class="line">        int[] group = new int[num];</span><br><span class="line">        </span><br><span class="line">        int sum = 0, n1 = 0, n2 = 0;</span><br><span class="line">        boolean finished = false;</span><br><span class="line">        int groupNum = 1;</span><br><span class="line">        </span><br><span class="line">        while(!finished) &#123;</span><br><span class="line">            int min = Integer.MAX_VALUE;</span><br><span class="line">            //找出所有边中最小值</span><br><span class="line">            for(int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">                for(int j = i+1; j &lt; num; j++) &#123;</span><br><span class="line">                    if(map[i][j] &gt; 0 &amp;&amp; map[i][j] &lt; min)&#123;</span><br><span class="line">                        //如果group相同，则表示处理过，不相同或都为0都表示没处理过</span><br><span class="line">                        if (group[i] != group[j] || (group[i] == 0 &amp;&amp; group[j] == 0)) &#123;</span><br><span class="line">                            min = map[i][j];</span><br><span class="line">                            n1 = i;</span><br><span class="line">                            n2 = j;    </span><br><span class="line">                        &#125;                                            </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(min == Integer.MAX_VALUE)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            System.out.println(n1 + &quot; ---&gt; &quot; + n2 + &quot; &quot; + min);</span><br><span class="line">            sum += min;</span><br><span class="line">            </span><br><span class="line">            //找到了最小值，设置连通标记</span><br><span class="line">            if(group[n1] == 0 &amp;&amp; group[n2] == 0)&#123;</span><br><span class="line">                group[n1] = groupNum;</span><br><span class="line">                group[n2] = groupNum;</span><br><span class="line">                groupNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(group[n1] &gt; 0 &amp;&amp; group[n2] &gt; 0) &#123;</span><br><span class="line">                int tmp = group[n2];</span><br><span class="line">                for(int m = 0; m &lt; group.length; m++)&#123;</span><br><span class="line">                    if(group[m] == tmp)&#123;</span><br><span class="line">                        group[m] = group[n1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(group[n1] == 0)&#123;</span><br><span class="line">                    group[n1] = group[n2];</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    group[n2] = group[n1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            for(int i = 0; i &lt; group.length; i++) &#123;</span><br><span class="line">                if(group[i] != group[0])&#123;</span><br><span class="line">                    finished = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    finished = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(finished) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot; sum:&quot;+sum);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　其结果如下：</p>
<p><img src="/img/greedy-algorithm/resultOfkrus.png" alt=""></p>
<p>　　<del>哈夫曼编码的生成算法留待下次再补。</del></p>
<p>　　补上哈夫曼编码的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">package greedyAlgorithm;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * huffman编码的java实现</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Huffman &#123;</span><br><span class="line">	//最大权值</span><br><span class="line">    static final int MAXVALUE=1000;</span><br><span class="line">    int nodeNum ; //叶子结点个数</span><br><span class="line">    </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">        int[] weight = &#123;20,19,18,17,15,10,1&#125;;</span><br><span class="line">        int n=weight.length ;</span><br><span class="line">        Huffman haffTree = new Huffman(n);</span><br><span class="line">        HuffNode[] nodes = new HuffNode[2*n-1];</span><br><span class="line">        Code[] codes = new Code[n]; </span><br><span class="line">        //构造哈夫曼树</span><br><span class="line">        haffTree.huffman(weight, nodes);</span><br><span class="line">        //生成哈夫曼编码</span><br><span class="line">        haffTree.huffmanCode(nodes, codes);</span><br><span class="line">        </span><br><span class="line">        //打印哈夫曼编码</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(&quot;Weight=&quot;+codes[i].weight+&quot; Code=&quot;);</span><br><span class="line">            for(int j=codes[i].start+1;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">               System.out.print(codes[i].bit[j]);    </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public Huffman(int n)</span><br><span class="line">    &#123;</span><br><span class="line">       this.nodeNum = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //构造哈夫曼树算法</span><br><span class="line">    public void huffman(int[] weight,HuffNode[] nodes)//权值数组，所有节点数组</span><br><span class="line">    &#123;</span><br><span class="line">        int n = this.nodeNum;</span><br><span class="line">        //m1,m2,表示最小的两个权值，x1,x2,表示最小两个权值对应的编号,m1表示最小，m2表示次小</span><br><span class="line">        int m1,m2,x1,x2; </span><br><span class="line">        </span><br><span class="line">        //初始化所有的结点，对应有n个叶子结点的哈夫曼树，有2n-1个结点。</span><br><span class="line">        for(int i=0;i &lt; 2*n-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            HuffNode temp = new HuffNode();</span><br><span class="line">            //初始化n个叶子结点，就是输入的节点。0、1、2、3是叶子节点也是输入的节点</span><br><span class="line">            if(i &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">               temp.weight = weight[i];    </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               temp.weight = 0;    </span><br><span class="line">            &#125;</span><br><span class="line">            temp.parent = 0;</span><br><span class="line">            temp.flag = 0;</span><br><span class="line">            temp.leftChild = -1;</span><br><span class="line">            temp.rightChild = -1;</span><br><span class="line">            nodes[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;n-1;i++)&#123;//初始化n-1个非叶子结点，n-1表示要循环n-1次求的n-1个数。</span><br><span class="line">           m1 = m2 = MAXVALUE;</span><br><span class="line">           x1 = x2 =0;</span><br><span class="line">           for(int j=0;j&lt; n+i;j++)//求得这n-1个数时，每次都是从0到n+i-1,并且flag=0的，flag=1表示已经加入到二叉树。</span><br><span class="line">           &#123;   //以下2步是找出权值最小的2个</span><br><span class="line">               if(nodes[j].weight&lt;m1 &amp;&amp; nodes[j].flag==0)//if成立了else if就不进去了。</span><br><span class="line">               &#123;</span><br><span class="line">                //m1,x1初始值为第一个元素，后面如果比m1要小，则m1指向更小的，原来m1指向的现在由m2指向，</span><br><span class="line">                //如果后面比m1大比m2小，则m2指向这个比m1大比m2小的，</span><br><span class="line">                //也就是说m1指向最小的，m2指向第2小的。</span><br><span class="line">                  m2 = m1;</span><br><span class="line">                  x2 = x1;</span><br><span class="line">                  m1 = nodes[j].weight;</span><br><span class="line">                  x1 = j;</span><br><span class="line">               &#125;</span><br><span class="line">               else if(nodes[j].weight&lt;m2 &amp;&amp; nodes[j].flag ==0)</span><br><span class="line">               &#123;</span><br><span class="line">                  m2 = nodes[j].weight;</span><br><span class="line">                  x2 = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //将权值最小的2个组合成一个2插树</span><br><span class="line">           nodes[x1].parent = n+i;</span><br><span class="line">           nodes[x2].parent = n+i;</span><br><span class="line">           nodes[x1].flag = 1;</span><br><span class="line">           nodes[x2].flag = 1;</span><br><span class="line">           nodes[n+i].weight = nodes[x1].weight + nodes[x2].weight;</span><br><span class="line">           nodes[n+i].leftChild = x1;</span><br><span class="line">           nodes[n+i].rightChild = x2;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //哈弗曼编码算法</span><br><span class="line">    public void huffmanCode(HuffNode[] nodes,Code[] haffCode)</span><br><span class="line">    &#123;</span><br><span class="line">        int n = this.nodeNum;</span><br><span class="line">        Code code = new Code(n);</span><br><span class="line">        int child,parent;</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;n; i++)//给前面n个输入的节点进行编码</span><br><span class="line">        &#123;</span><br><span class="line">           code.start = n-1;</span><br><span class="line">           code.weight = nodes[i].weight;</span><br><span class="line">           child = i;</span><br><span class="line">           parent = nodes[child].parent;</span><br><span class="line">           //从叶子节点向上走来生成编码，画图即可。</span><br><span class="line">           while(parent!=0)</span><br><span class="line">           &#123;</span><br><span class="line">              if(nodes[parent].leftChild == child)</span><br><span class="line">              &#123;</span><br><span class="line">                  code.bit[code.start] = 0;</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">              &#123;</span><br><span class="line">                  code.bit[code.start] = 1;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">              code.start--; </span><br><span class="line">              child = parent;</span><br><span class="line">              parent = nodes[child].parent;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           Code temp = new Code(n);</span><br><span class="line">           for(int j=code.start+1;j &lt; n;j++)</span><br><span class="line">           &#123;</span><br><span class="line">               temp.bit[j] = code.bit[j];</span><br><span class="line">           &#125;</span><br><span class="line">           temp.weight = code.weight;</span><br><span class="line">           temp.start = code.start;</span><br><span class="line">           haffCode[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	//哈夫曼树的结点类</span><br><span class="line">	 class HuffNode &#123;</span><br><span class="line">	   </span><br><span class="line">	    int weight; //权值</span><br><span class="line">	    int parent ;//他的双亲</span><br><span class="line">	    int flag ;//标志，是否为叶子节点</span><br><span class="line">	    int leftChild; //他的左孩子</span><br><span class="line">	    int rightChild;//他的右孩子</span><br><span class="line">	    </span><br><span class="line">	    HuffNode()</span><br><span class="line">	    &#123;</span><br><span class="line">	        </span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//哈夫曼编码类</span><br><span class="line">	 class Code &#123;</span><br><span class="line"></span><br><span class="line">	    int[] bit;  //编码的数组</span><br><span class="line">	    int start;  //编码的开始下标</span><br><span class="line">	    int weight; //权值</span><br><span class="line">	    Code(int n)&#123;</span><br><span class="line">	        bit = new int[n];</span><br><span class="line">	        start = n-1;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　上次课老师讲了贪心算法，贪心算法的基本思路很简单，最接近没有学习算法的人的一般思维模式，因而也最好理解，核心的思路是总是作出当前看来最好的选择。&lt;/p&gt;
&lt;p&gt;　　可用贪心算法解决的经典问题有：活动安排问题、Dijkstra算法、Prim算法、Kruskal算法、Haf
    
    </summary>
    
      <category term="算法寻径" scheme="http://jrhu05.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BB%E5%BE%84/"/>
    
    
      <category term="贪心算法" scheme="http://jrhu05.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划相关实例</title>
    <link href="http://jrhu05.github.io/post/dynamic-programming.html"/>
    <id>http://jrhu05.github.io/post/dynamic-programming.html</id>
    <published>2015-05-20T10:36:06.000Z</published>
    <updated>2015-05-22T12:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　之前的一次课老师给动态规划开了个头，虽然听得云里雾里的，不过感觉动态规划的解决问题思路很像我以前学的运筹学的解决问题的思维方式。</p>
<p>　　尤其是做到LCS问题的时候画的那个矩阵，极其像我以前求输水管最佳排布之类问题时画的那种矩阵。</p>
<p>　　动态规划具有的两个特性与运筹学中的最优化问题涉及到的特性高度一致：子问题的高度重复性、最优子结构性质，此外问题的最优解中包含着其每一个子问题的最优解也是一样的。</p>
<p>　　课后又自己琢磨的半天，对动态规划的核心思路有了一点浅显的认识。课上留下了两个问题，第一个是矩阵连乘问题，第二个是LCS问题。下面一一给出大概的描述和解决思路以及java实现的解题代码。</p>
<p>　　矩阵连乘问题：</p>
<p>　　问题描述</p>
<p>　　* 矩阵连乘问题（矩阵链乘法）</p>
<p>　　一般描述：</p>
<p>　　对于给定的n个矩阵，M 1 ， M 2 ，…， M n ，其中矩阵M i 和M j 是可乘的，要求确定计算矩阵连乘积（ M 1 M 2 …M n ）的计算次序，使得按照该次数计算矩阵连乘积时需要的乘法次数最少</p>
<p>　　例 ，设有矩阵M 1 ,M 2 ,M 3 ,M 4</p>
<p>　　其维数分别是：10×20, 20×50,50×1 ,1×100</p>
<p>　　现要求出这4个矩阵相乘的结果</p>
<p>　　计算次序可以通过加括号的方式确定</p>
<p>　　代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 矩阵连乘问题的动态规划方法求解</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MatrixMultiplication &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] p=&#123;10,20,50,1,100&#125;;//表示10*20的矩阵再乘上20*50再乘上XXX类推</span><br><span class="line">		double times=multiplication(p,3);</span><br><span class="line">		System.out.println(times);</span><br><span class="line">	&#125;</span><br><span class="line">/**</span><br><span class="line">	 * 计算最小的乘法次数</span><br><span class="line">	 * @param p</span><br><span class="line">	 * @param end 需要计算到的位置</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	private static double multiplication(int[] p,int end) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		double[][] m = new double[end+1][end+1];</span><br><span class="line">		for (int i = 0; i &lt;=end; i++) &#123;</span><br><span class="line">			m[i][i]=0;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int l = 1; l &lt; end; l++) &#123;</span><br><span class="line">			for (int i = 1; i &lt;= end-l; i++) &#123;</span><br><span class="line">				int j=i+l;</span><br><span class="line">				double min;</span><br><span class="line">				//矩阵M t 的列数为r t </span><br><span class="line">				min=m[i][i]+m[i+1][j]+p[i-1]*p[i]*p[j];</span><br><span class="line">				for(int k=i;k&lt;j;k++)&#123;</span><br><span class="line">					double temp=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j];</span><br><span class="line">					if (temp&lt;min) &#123;</span><br><span class="line">						min=temp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				m[i][j]=min;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		return m[1][end];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　最长公共子序列问题（LCS问题）：</p>
<p>　　问题的描述和求解思路网上有很多现成的资料，不在赘述直接贴实现的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package dynamicProgramming;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 动态规划法求解最长公共子序列问题</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LCS &#123;</span><br><span class="line">	static int count=0;</span><br><span class="line">	static int max_lcs_length=0;</span><br><span class="line">	static String[] result;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String[] s1=&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;B&quot;,&quot;D&quot;,&quot;A&quot;,&quot;B&quot;&#125;;</span><br><span class="line">		String[] s2=&#123;&quot;B&quot;,&quot;D&quot;,&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;&#125;;</span><br><span class="line">		System.out.println(&quot;s1: &quot;+Arrays.toString(s1));</span><br><span class="line">		System.out.println(&quot;s2: &quot;+Arrays.toString(s2));</span><br><span class="line">		int row=s1.length+1;</span><br><span class="line">		int col=s2.length+1;</span><br><span class="line">		lcs(s1,s2, row, col);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void lcs(String[] s1, String[] s2,int row,int col) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		int[][] matrix=new int[row][col];</span><br><span class="line">		String[][] operation=new String[row][col];</span><br><span class="line">		for(int i=0;i&lt;col;i++)&#123;</span><br><span class="line">			matrix[0][i]=0;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j=0;j&lt;row;j++)&#123;</span><br><span class="line">			matrix[j][0]=0;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=1;i&lt;row;i++)&#123;</span><br><span class="line">			for(int j=1;j&lt;col;j++)&#123;</span><br><span class="line">				if (s1[i-1]==s2[j-1]) &#123;</span><br><span class="line">					matrix[i][j]=matrix[i-1][j-1]+1;</span><br><span class="line">					operation[i][j]=&quot;upleft&quot;;</span><br><span class="line">				&#125;else if (matrix[i-1][j]&gt;matrix[i][j-1]) &#123;</span><br><span class="line">					matrix[i][j]=matrix[i-1][j];</span><br><span class="line">					operation[i][j]=&quot;up&quot;;</span><br><span class="line">				&#125;else if(matrix[i-1][j]&lt;matrix[i][j-1])&#123;</span><br><span class="line">					matrix[i][j]=matrix[i][j-1];</span><br><span class="line">					operation[i][j]=&quot;left&quot;;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					matrix[i][j]=matrix[i-1][j];</span><br><span class="line">					operation[i][j]=&quot;upOrLeft&quot;;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//打印操作矩阵</span><br><span class="line">//		for (int i = 0; i &lt; operation.length; i++) &#123;</span><br><span class="line">//			String[] strings = operation[i];</span><br><span class="line">//			System.out.println(Arrays.toString(strings));</span><br><span class="line">//		&#125;</span><br><span class="line">		System.out.println(&quot;the lcs&apos;s length is: &quot;+matrix[row-1][col-1]);</span><br><span class="line">		max_lcs_length=matrix[row-1][col-1];</span><br><span class="line">		result=new String[max_lcs_length];</span><br><span class="line">		System.out.println(&quot;lcs is: &quot;);</span><br><span class="line">		lcs_outPut(operation,s1,row-1,col-1,max_lcs_length);</span><br><span class="line">		//打印计算矩阵</span><br><span class="line">//		for (int i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">//			int[] js = matrix[i];</span><br><span class="line">//			for (int j = 0; j &lt; js.length; j++) &#123;</span><br><span class="line">//				int s = js[j];</span><br><span class="line">//				System.out.print(s+&quot; &quot;);</span><br><span class="line">//			&#125;</span><br><span class="line">//			System.out.println();</span><br><span class="line">//		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void lcs_outPut(String[][] operation, String[] s1, int row,</span><br><span class="line">			int col,int current_len) &#123;</span><br><span class="line">		if (row==0||col==0) &#123;</span><br><span class="line">			for(int s=0; s &lt; max_lcs_length; s++)</span><br><span class="line">	         &#123;</span><br><span class="line">	             System.out.print(result[s]);</span><br><span class="line">	         &#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">	         count++;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (operation[row][col].equals(&quot;upleft&quot;)) &#123;</span><br><span class="line">			current_len--;</span><br><span class="line">			result[current_len]=s1[row-1];</span><br><span class="line">			lcs_outPut(operation, s1, row-1, col-1,current_len);</span><br><span class="line">			</span><br><span class="line">		&#125;else if (operation[row][col].equals(&quot;up&quot;)) &#123;</span><br><span class="line">			lcs_outPut(operation, s1, row-1, col,current_len);</span><br><span class="line">		&#125;else if (operation[row][col].equals(&quot;left&quot;)) &#123;</span><br><span class="line">			lcs_outPut(operation, s1, row, col-1,current_len);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			//等于的时候搜索上和左两侧的可能的操作集合</span><br><span class="line">			lcs_outPut(operation, s1, row-1, col,current_len);</span><br><span class="line">			lcs_outPut(operation, s1, row, col-1,current_len);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　LCS问题测试数据的运行结果如下：<br><img src="/img/dynamic-programming-part1/lcsResult.jpg" alt=""></p>
<p>　　上周老师又给我们另外讲了几个动态规划的典型实例，最大子段和与01背包问题的动态规划解法。</p>
<p>　　最大子段和的解法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package dynamicProgramming;</span><br><span class="line">/**</span><br><span class="line"> * 最大子段和问题的动态规划方法求解</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MaxSubSum &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] a=&#123;-2,11,-4,13,-5,-2&#125;;</span><br><span class="line">		maxSum(a);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void maxSum(int[] a) &#123;</span><br><span class="line">		int n=a.length;</span><br><span class="line">		int sum=0,b=0;//初始化最大子段和为0，b[0]为0</span><br><span class="line">		int start=0,end=0;</span><br><span class="line">		for (int i=0;i&lt;n;i++) &#123;</span><br><span class="line">			if (b&gt;0) &#123;</span><br><span class="line">				b+=a[i];</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				b=a[i];</span><br><span class="line">				start=i;</span><br><span class="line">			&#125;</span><br><span class="line">			if (b&gt;sum) &#123;</span><br><span class="line">				sum=b;//更新找到的最大子段</span><br><span class="line">				end=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;max subline sum is: &quot;+sum);</span><br><span class="line">		System.out.println(&quot;from &quot;+(start+1)+&quot; to &quot;+(end+1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  01背包问题的例题与实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package dynamicProgramming;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 01背包问题的动态规划方法求解</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ZeroOneBag &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 例题</span><br><span class="line">	 * 假设现有容量10kg的背包，另外有3个物品，分别为a1，a2，a3。物品a1重量为3kg，</span><br><span class="line">	 * 价值为4；物品a2重量为4kg，价值为5；物品a3重量为5kg，价值为6。</span><br><span class="line">	 * 将哪些物品放入背包可使得背包中的总价值最大？</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] w=&#123;3,4,5&#125;;//各个物品的重量</span><br><span class="line">		int[] v=&#123;4,5,6&#125;;//各个物品对应的价值</span><br><span class="line">		int capacity=10;//背包容量</span><br><span class="line">		int maxValue= knap(w,v,capacity);</span><br><span class="line">		System.out.println(&quot;the max value: &quot;+maxValue);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static int knap(int[] w,int[] v,int capacity) &#123;</span><br><span class="line">		int num=w.length;</span><br><span class="line">		//将重量数组处理为[0,3,4...]方便后续处理</span><br><span class="line">		int[] weight=new int[num+1];</span><br><span class="line">		weight[0]=0;</span><br><span class="line">		for (int i = 0; i &lt; w.length; i++) &#123;</span><br><span class="line">			weight[i+1]=w[i];</span><br><span class="line">		&#125;</span><br><span class="line">		//同样处理价值数组</span><br><span class="line">		int value[]=new int[num+1];</span><br><span class="line">		value[0]=1;</span><br><span class="line">		for (int i = 0; i &lt; v.length; i++) &#123;</span><br><span class="line">			value[i+1] = v[i];</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		//建立用于求解需要的矩阵</span><br><span class="line">		int[][] c=new int[num+1][capacity+1];</span><br><span class="line">		//初始化</span><br><span class="line">		for (int i = 0; i &lt; num+1; i++) &#123;</span><br><span class="line">			c[i][0]=0;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int j = 0; j &lt; capacity+1; j++) &#123;</span><br><span class="line">			c[0][j]=0;</span><br><span class="line">		&#125;</span><br><span class="line">		//构建该矩阵</span><br><span class="line">		for (int i = 1; i &lt; num+1; i++) &#123;</span><br><span class="line">			for (int j = 1; j &lt; capacity+1; j++) &#123;</span><br><span class="line">				c[i][j]=c[i-1][j];</span><br><span class="line">				if (weight[i]&lt;=j) &#123;</span><br><span class="line">					c[i][j]=Math.max(c[i][j],(c[i-1][j-weight[i]]+value[i]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = 0; i &lt; c.length; i++) &#123;</span><br><span class="line">			int[] js = c[i];</span><br><span class="line">			System.out.println(Arrays.toString(js));</span><br><span class="line">		&#125;</span><br><span class="line">		return c[num][capacity];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　之前的一次课老师给动态规划开了个头，虽然听得云里雾里的，不过感觉动态规划的解决问题思路很像我以前学的运筹学的解决问题的思维方式。&lt;/p&gt;
&lt;p&gt;　　尤其是做到LCS问题的时候画的那个矩阵，极其像我以前求输水管最佳排布之类问题时画的那种矩阵。&lt;/p&gt;
&lt;p&gt;　　动态规划具
    
    </summary>
    
      <category term="算法寻径" scheme="http://jrhu05.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BB%E5%BE%84/"/>
    
    
      <category term="LCS问题" scheme="http://jrhu05.github.io/tags/LCS%E9%97%AE%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://jrhu05.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>硬件方式破解天翼校园客户端1.5.4</title>
    <link href="http://jrhu05.github.io/post/jsEsurfing-newVersion-crack.html"/>
    <id>http://jrhu05.github.io/post/jsEsurfing-newVersion-crack.html</id>
    <published>2015-05-12T04:37:48.000Z</published>
    <updated>2015-07-14T00:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　自从上次破解完1.5.2版本后，不久电信就进行了升级，中间我路由器拿到实验室用了，所以也没进行相应的破解升级工作。前几天电信开始频繁掉线，尤其是lol进游戏加载的时候会一直掉，导致我本来就不高的排位一直掉，一怒之下接着破解。</p>
<p>　　本教程适用于电信天翼校园客户端1.5.4和1.5.5的地区，我所在的苏州地区亲测没有问题。</p>
<p>　　首先你需要一个改装好的水星155r路由，动手能力强的同学可以买原版的星155r路由回来改装，才40来块钱，要是像我这样的硬件小白可以直接去淘宝上买别人改装好的。下面给个链接：</p>
<p>　　<a href="http://item.taobao.com/item.htm?spm=a1z09.2.9.28.6HaVYe&amp;id=37833970907&amp;_u=cl66d0vcf3f" target="_blank" rel="external">http://item.taobao.com/item.htm?spm=a1z09.2.9.28.6HaVYe&amp;id=37833970907&amp;_u=cl66d0vcf3f</a></p>
<p>　　店家默认给刷了个不死uboot。</p>
<p>　　下面开始刷机教程，刷入的系统是OpenWrt 的稳定版Attitude Adjustment 12.09.1 / LuCI 0.11 Branch内核是3.3.8的，所需要的工具和固件我会打包放在百度盘里，大家可以自行去下载。
　　</p>
<p>　　首先设置ip如图</p>
<p><img src="/img/jsEsurfing-crack/step1.jpg" alt=""></p>
<p>　　接着进入不死uboot，进入方法：按着reset不放插上电源，等到灯一起闪的时候，清空浏览器缓存，不要用IE。进入192.168.1.1</p>
<p>　　进入后就可以刷入固件了，待刷入的固件名称是155r.bin</p>
<p>　　刷入的设置界面如下：</p>
<p><img src="/img/jsEsurfing-newVersion-crack/different1.jpg" alt=""></p>
<p>　　耐心等待系统的刷入，刷入后，等灯重新亮起之后，将IP 改回自动获取，进入192.168.1.1.用户名为root默认密码为小写admin，此时你已经成功进入了系统，离成功破解更近了一步。</p>
<p>　　下面进行pppd文件的写入，安装好winscp后打开，设置界面如下图：</p>
<p><img src="/img/jsEsurfing-newVersion-crack/different2.jpg" alt=""></p>
<p>　　密码是：admin，别的和上图都一样，然后点击登录。</p>
<p>　　把pppd拖到路由root根文件夹下（打开主目录）具体看下图：</p>
<p><img src="/img/jsEsurfing-crack/step4.jpg" alt=""></p>
<p>　　上传好的界面如下：</p>
<p><img src="/img/jsEsurfing-crack/step5.jpg" alt=""></p>
<p>　　下面安装好putty并打开<br><img src="/img/jsEsurfing-newVersion-crack/different3.jpg" alt=""></p>
<p>　　填好hostname为192.168.1.1后点击open打开终端</p>
<p><img src="/img/jsEsurfing-newVersion-crack/different4.jpg" alt=""></p>
<p>　　输入用户名：root，密码：admin（注意terminal默认是没有密码回显的小心别敲错了），登陆成功后的界面如上图。</p>
<p>　　在里面输入（可以直接选中再在putty里右击，会自动copy过去的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/sbin/pppd /usr/sbin/pppd.bak</span><br><span class="line">cp /root/pppd /usr/sbin/pppd</span><br><span class="line">chmod +x /usr/sbin/pppd</span><br></pre></td></tr></table></figure></p>
<p>　　其实就是简单的linux命令，第一个是把原来的pppd备份一下，防止有啥问题好用来还原，第二句是把传上去的pppd拷贝到用户目录，最后一句是给pppd加权限，看懂看不懂没啥影响，照着来就可以了。</p>
<p>　　再次进入192.168.1.1 把wan口的协议改成pppoe，然后保存&amp;应用，如下图：</p>
<p><img src="/img/jsEsurfing-crack/step8.jpg" alt=""></p>
<p>　　打开wan口高级设置，取消开机自动运行（把下图的打钩取消掉）。</p>
<p><img src="/img/jsEsurfing-crack/step9.jpg" alt=""></p>
<p>　　保存&amp;应用，之后重启一下路由。</p>
<p>　　再进入路由器，配置一下wan口的基本设置</p>
<p><img src="/img/jsEsurfing-newVersion-crack/different5.jpg" alt=""></p>
<p>　　用户名是tyxy#+天翼帐号，比如手机号码 18111111111对应的拨号帐号就是tyxy#18111111111，密码是6小时一换的密码，配置好后点击保存和应用。</p>
<p>　　然后回到上一级，点击wan的链接：</p>
<p><img src="/img/jsEsurfing-crack/step11.jpg" alt=""></p>
<p>　　然后和小伙伴一起享受无拘无束的共享上网吧！</p>
<p>　　Enjoying it!</p>
<p>　　本文所需的软件和固件打包下载地址如下：</p>
<p>　　链接:<a href="http://pan.baidu.com/s/1qWmgyeS" title="破解所需软件" target="_blank" rel="external"> http://pan.baidu.com/s/1qWmgyeS</a> </p>
<p>　　密码: uc3p</p>
<p>　　压缩文件解压密码是:www.jerryfu.net</p>
<p>　　之前忘记有加密这回事了，sorry。</p>
<p>　　如果链接失效可以直接找我索要。</p>
<p>　　关于openwrt如何开启无线网和配置无线网的内容过于简单且不再本文讨论范围内，故省略，如有疑问可自行百度。</p>
<p>　　如需转载，请注明出处，谢谢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　自从上次破解完1.5.2版本后，不久电信就进行了升级，中间我路由器拿到实验室用了，所以也没进行相应的破解升级工作。前几天电信开始频繁掉线，尤其是lol进游戏加载的时候会一直掉，导致我本来就不高的排位一直掉，一怒之下接着破解。&lt;/p&gt;
&lt;p&gt;　　本教程适用于电信天翼校园客
    
    </summary>
    
      <category term="网络安全" scheme="http://jrhu05.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="电信客户端破解" scheme="http://jrhu05.github.io/tags/%E7%94%B5%E4%BF%A1%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>最近点对问题分治法求解的java实现</title>
    <link href="http://jrhu05.github.io/post/nearest-point-pairs.html"/>
    <id>http://jrhu05.github.io/post/nearest-point-pairs.html</id>
    <published>2015-05-07T09:02:11.000Z</published>
    <updated>2015-05-07T09:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　　上上周老师讲完了递归与分治的最后一部分，然后给动态规划开了个头。其中有一个问题很有意思，即经典的最近点对问题。</p>
<p>　　　问题大致为：给出若干个二维平面的点对，求解最近的点对及其之间的距离。</p>
<p>　　　肯定不能用暴力穷举的方法，我机器实测在点对数量达到十万级别的时候该方法的计算时间就已经很长了（至少好几十秒），等了半天程序没出结果，最后我只好自己手动停止。</p>
<p>　　　分治法解决该问题重点在于merge部分，相关的理论及流程分析网上一搜一大堆，我也不再赘述。</p>
<p>　　　简单爬一下老师给的ppt里的解题思路：</p>
<p>　　　预处理</p>
<p>　　　　将点对按X坐标排序</p>
<p>　　　　将点对按Y坐标排序</p>
<p>　　　分解</p>
<p>　　　　按照X坐标将点集二分</p>
<p>　　　　同时获得分解后的已按Y坐标排好序的点集</p>
<p>　　　递归求解</p>
<p>　　　合并</p>
<p>　　　　找出带状区域中的点</p>
<p>　　　　检查带状区域中的点（已排序），计算每点与其后面7个点的距离，更新最近点对距离</p>
<p>　　　至于为什么是7个点，可自行搜索鸽巢原理。</p>
<p>　　　下面贴代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line">package divideAndConquer;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最近点对问题求解</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class NearestPointPairs &#123;</span><br><span class="line">	static final int MOUNT=30;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Set&lt;Point&gt; testData = new TreeSet&lt;Point&gt;();  </span><br><span class="line">        </span><br><span class="line">        Random random = new Random();  </span><br><span class="line">          </span><br><span class="line">        int x = 0;  </span><br><span class="line">        int y = 0;  </span><br><span class="line">          </span><br><span class="line">        for(int i = 0;i &lt; 100000;i++)&#123;  </span><br><span class="line">            x = random.nextInt(500000);  </span><br><span class="line">            y = random.nextInt(500000);  </span><br><span class="line">            testData.add(new Point(x, y));  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        Point [] points = new Point[testData.size()];  </span><br><span class="line">        points = (Point[]) testData.toArray(points);            </span><br><span class="line">        System.out.println(testData.size());  </span><br><span class="line">		Point[] resultpPoints=new Point[2];</span><br><span class="line">		long startTime=System.currentTimeMillis();   //获取开始时间</span><br><span class="line">		//resultpPoints=boundary(points);</span><br><span class="line">		resultpPoints=findNearest(points);</span><br><span class="line">		long endTime=System.currentTimeMillis(); //获取结束时间</span><br><span class="line">		System.out.println(&quot;the nearest point pairs is: (&quot;+resultpPoints[0].getX()+&quot;,&quot;+resultpPoints[0].getY()</span><br><span class="line">							+&quot;)--(&quot;+resultpPoints[1].getX()+&quot;,&quot;+resultpPoints[1].getY()+&quot;)&quot;);</span><br><span class="line">		System.out.println(&quot;their distance is: &quot;+distance(resultpPoints[0], resultpPoints[1]));</span><br><span class="line">		System.out.println(&quot;time cost of ctAlgorithm is： &quot;+(endTime-startTime)+&quot;ms&quot;);</span><br><span class="line">		startTime=System.currentTimeMillis();   //获取开始时间</span><br><span class="line">		resultpPoints=boundary(points);</span><br><span class="line">		//resultpPoints=findNearest(points);</span><br><span class="line">		 endTime=System.currentTimeMillis(); //获取结束时间</span><br><span class="line">		System.out.println(&quot;time cost of nomorl alogtithm is： &quot;+(endTime-startTime)+&quot;ms&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static Point[] findNearest(Point[] p)&#123;</span><br><span class="line">		Point[] result=new Point[2];</span><br><span class="line">		//如果小于某一边界条件则用暴力穷举计算</span><br><span class="line">		if (p.length&lt;=MOUNT) &#123;</span><br><span class="line">		 	return boundary(p);</span><br><span class="line">		&#125;</span><br><span class="line">		//分治法核心</span><br><span class="line">		//step1.求所有点在X坐标的中位数  </span><br><span class="line">        int minX = (int) Double.POSITIVE_INFINITY;      //保证假设的初始最小值足够大  </span><br><span class="line">        int maxX = (int) Double.NEGATIVE_INFINITY;      //保证假设的初始最大值足够小 </span><br><span class="line">        for(int i = 0; i &lt; p.length; i++)&#123;  </span><br><span class="line">            if(p[i].getX() &lt; minX)  </span><br><span class="line">                minX = (int) p[i].getX();  </span><br><span class="line">            if(p[i].getX() &gt; maxX)  </span><br><span class="line">                maxX = (int) p[i].getX();  </span><br><span class="line">        &#125;  </span><br><span class="line">        int midX = (minX + maxX)/2;</span><br><span class="line">        //step2.以midX为界将所有点分成两组分别存放在两个表中</span><br><span class="line">        ArrayList&lt;Point&gt; T1 = new ArrayList&lt;Point&gt;();  </span><br><span class="line">        ArrayList&lt;Point&gt; T2 = new ArrayList&lt;Point&gt;();  </span><br><span class="line">        for(int i = 0; i &lt; p.length; i++)&#123;  </span><br><span class="line">            if(p[i].getX() &lt;= midX)       </span><br><span class="line">                T1.add(p[i]);  </span><br><span class="line">            if(p[i].getX() &gt; midX)  </span><br><span class="line">                T2.add(p[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        //step3.将两张表转化为数组类型，并分别按X坐标升序排列</span><br><span class="line">        Point [] p1 = new Point[T1.size()];  </span><br><span class="line">        Point [] p2 = new Point[T2.size()];  </span><br><span class="line">          </span><br><span class="line">        T1.toArray(p1);  </span><br><span class="line">        T2.toArray(p2);  </span><br><span class="line">          </span><br><span class="line">        mergeSort(p1, &quot;x&quot;);     //按X坐标升序排列  </span><br><span class="line">        mergeSort(p2, &quot;x&quot;);     //按X坐标升序排列 </span><br><span class="line">        //step4.求p1、p2中的最近距离的两个点</span><br><span class="line">        Point[] result1 = new Point[2];  </span><br><span class="line">        result1 = findNearest(p1);</span><br><span class="line">        Point[] result2 = new Point[2];  </span><br><span class="line">        result2 = findNearest(p2);</span><br><span class="line">        //step5.求二者中的最小值</span><br><span class="line">        if (distance(result1[0], result1[1])&lt;distance(result2[0], result2[1])) &#123;</span><br><span class="line">			result=result1;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			result=result2;</span><br><span class="line">		&#125;</span><br><span class="line">        double d=Math.min(distance(result1[0], result1[1]),distance(result2[0], result2[1]));</span><br><span class="line">        //step6在两个子点集中搜索距离中位线距离小于d的点并存起来</span><br><span class="line">        ArrayList&lt;Point&gt; T3 = new ArrayList&lt;Point&gt;();   </span><br><span class="line">        for(int i = 0; i &lt; p1.length; i++)&#123;  </span><br><span class="line">            if(midX - p1[i].getX() &lt; d)  </span><br><span class="line">                T3.add(p1[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        for(int i = 0; i &lt; p2.length; i++)&#123;  </span><br><span class="line">            if(p2[i].getX() - midX &lt; d)&#123;  </span><br><span class="line">                T3.add(p2[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        //step7.将得到的子表转成数组并且按照y的升序排列</span><br><span class="line">        Point [] p3 = new Point [T3.size()];  </span><br><span class="line">        T3.toArray(p3);            </span><br><span class="line">        mergeSort(p3, &quot;y&quot;);  </span><br><span class="line">        //step8.根据鸽笼理论，只需检查T3中的每个点的后8个点和d进行比对即可</span><br><span class="line">        if (p3.length&lt;MOUNT) &#123;</span><br><span class="line">			Point[] tempPoints= boundary(p3);</span><br><span class="line">			if (distance(tempPoints[0], tempPoints[1])&lt;d&amp;&amp;distance(tempPoints[0], tempPoints[1])!=0) &#123;</span><br><span class="line">				result=tempPoints;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			for(int i=0;i&lt;p3.length-7;i++)&#123;</span><br><span class="line">				double tempd;</span><br><span class="line">				for(int j=1;j&lt;8;j++)&#123;</span><br><span class="line">					if (i+j&gt;=p3.length) &#123;</span><br><span class="line">						break;</span><br><span class="line">					&#125;else &#123;</span><br><span class="line">						tempd=distance(p3[i], p3[i+j]);</span><br><span class="line">						if (tempd&lt;d&amp;tempd!=0) &#123;</span><br><span class="line">							result[0]=p3[i];</span><br><span class="line">							result[1]=p3[i+j];</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">       </span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 求两点之间距离</span><br><span class="line">	 * @param p1</span><br><span class="line">	 * @param p2</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	static double distance(Point p1,Point p2)&#123;</span><br><span class="line">		return Math.sqrt((p1.getX()-p2.getX())*(p1.getX()-p2.getX())+(p1.getY()-p2.getY())*(p1.getY()-p2.getY()));</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 将点集按照特定顺序升序排列（x坐标或者y坐标）</span><br><span class="line">	 * @param p1</span><br><span class="line">	 * @param string</span><br><span class="line">	 */</span><br><span class="line">	private static void mergeSort(Point[] p, String property) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		Point[] tempArray = new Point[p.length];  </span><br><span class="line">        mergeSort(p, tempArray, 0, p.length - 1, property); </span><br><span class="line">	&#125;</span><br><span class="line">	private static void mergeSort(Point[] a, Point [] tempArray, int left, int right, String property)&#123;  </span><br><span class="line">        if(left &lt; right)&#123;  </span><br><span class="line">            int center = (left + right) &gt;&gt; 1;  </span><br><span class="line">            //分治  </span><br><span class="line">            mergeSort(a, tempArray, left, center, property);  </span><br><span class="line">            mergeSort(a, tempArray, center + 1, right, property);  </span><br><span class="line">            //合并  </span><br><span class="line">            merge(a, tempArray, left, center + 1, right, property);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">	  private static void merge(Point [] a, Point [] tempArray, int leftPos, int rightPos, int rightEnd, String property)&#123;  </span><br><span class="line">	        int leftEnd = rightPos - 1;  </span><br><span class="line">	        int numOfElements = rightEnd - leftPos + 1;  </span><br><span class="line">	          </span><br><span class="line">	        int tmpPos = leftPos;       //游标变量, 另两个游标变量分别是leftPos 和 rightPos  </span><br><span class="line">	          </span><br><span class="line">	        while(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd)&#123;  </span><br><span class="line">	            if(property.equals(&quot;x&quot;))&#123;  </span><br><span class="line">	                if(a[leftPos].getX() &lt;= a[rightPos].getX())  </span><br><span class="line">	                    tempArray[tmpPos++] = a[leftPos++];  </span><br><span class="line">	                else  </span><br><span class="line">	                    tempArray[tmpPos++] = a[rightPos++];  </span><br><span class="line">	            &#125;else if(property.equals(&quot;y&quot;))&#123;  </span><br><span class="line">	                if(a[leftPos].getY() &lt;= a[rightPos].getY())  </span><br><span class="line">	                    tempArray[tmpPos++] = a[leftPos++];  </span><br><span class="line">	                else  </span><br><span class="line">	                    tempArray[tmpPos++] = a[rightPos++];  </span><br><span class="line">	            &#125;else  </span><br><span class="line">	                throw new RuntimeException();  </span><br><span class="line">	        &#125;  </span><br><span class="line">	          </span><br><span class="line">	        while(leftPos &lt;= leftEnd)  </span><br><span class="line">	            tempArray[tmpPos++] = a[leftPos++];  </span><br><span class="line">	        while(rightPos &lt;= rightEnd)  </span><br><span class="line">	            tempArray[tmpPos++] = a[rightPos++];  </span><br><span class="line">	          </span><br><span class="line">	        //将排好序的段落拷贝到原数组中  </span><br><span class="line">	        System.arraycopy(tempArray, rightEnd-numOfElements+1, a, rightEnd-numOfElements+1, numOfElements);  </span><br><span class="line">	    &#125;  </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 边界和数据较小时候的穷举法求最短距离</span><br><span class="line">	 * @param p 输入点对数组</span><br><span class="line">	 * @return 最小距离</span><br><span class="line">	 */</span><br><span class="line">	static Point[] boundary(Point[] p)&#123;</span><br><span class="line">		Point[] resultpPoints=new Point[2];</span><br><span class="line">		if (p.length&lt;=1) &#123;</span><br><span class="line">			resultpPoints[0]=new Point(Double.MIN_VALUE, Double.MIN_VALUE);</span><br><span class="line">			resultpPoints[1]=new Point(Double.MAX_VALUE, Double.MAX_VALUE);</span><br><span class="line">			return resultpPoints;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			double min=distance(p[0], p[1]);</span><br><span class="line">			int start=0;</span><br><span class="line">			int end=1;</span><br><span class="line">			for (int i = 0; i &lt; p.length; i++) &#123;</span><br><span class="line">				for (int j = i+1; j &lt; p.length; j++) &#123;</span><br><span class="line">					if (distance(p[i], p[j])&lt;min&amp;&amp;distance(p[i], p[j])!=0) &#123;</span><br><span class="line">						min=distance(p[i], p[j]);</span><br><span class="line">						start=i;</span><br><span class="line">						end=j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			resultpPoints[0]=p[start];</span><br><span class="line">			resultpPoints[1]=p[end];</span><br><span class="line">			return resultpPoints;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//用一个类来表示点</span><br><span class="line">class Point implements  Cloneable,Comparable&lt;Point&gt;&#123;</span><br><span class="line">	double x,y;</span><br><span class="line"></span><br><span class="line">	public Point(double x, double y) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.x = x;</span><br><span class="line">		this.y = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double getX() &#123;</span><br><span class="line">		return x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double getY() &#123;</span><br><span class="line">		return y;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override  </span><br><span class="line">    public int compareTo(Point o) &#123;  </span><br><span class="line">        if(x == o.getX() &amp;&amp; y == o.getY())  </span><br><span class="line">            return 0;  </span><br><span class="line">        else   </span><br><span class="line">            return 1;  </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object p) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		if (this.x==((Point) p).getX()&amp;&amp;this.y==((Point) p).getY()) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//	@Override</span><br><span class="line">//	public int hashCode() &#123;</span><br><span class="line">//		// TODO 自动生成的方法存根</span><br><span class="line">//		return (int) ((x+y)*12345);</span><br><span class="line">//	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　　在解决该问题的时候参考了这位作者的文章：<a href="http://blog.csdn.net/liyong199012/article/details/38520475" target="_blank" rel="external">http://blog.csdn.net/liyong199012/article/details/38520475</a><br>并且对他的方法进行了改进，规避了其原来的数据量很大的时候会出现堆栈溢出以及treeset有重复元的问题。</p>
<p>　　　比对一下两种方法的计算时间，可以发现分治法极大的提高了计算效率。</p>
<p><img src="/img/nearest-point-pairs/result.jpg" alt=""></p>
<p>　　　第一行的是问题的规模。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　　上上周老师讲完了递归与分治的最后一部分，然后给动态规划开了个头。其中有一个问题很有意思，即经典的最近点对问题。&lt;/p&gt;
&lt;p&gt;　　　问题大致为：给出若干个二维平面的点对，求解最近的点对及其之间的距离。&lt;/p&gt;
&lt;p&gt;　　　肯定不能用暴力穷举的方法，我机器实测在点对数量
    
    </summary>
    
      <category term="算法寻径" scheme="http://jrhu05.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BB%E5%BE%84/"/>
    
    
      <category term="最近点对" scheme="http://jrhu05.github.io/tags/%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/"/>
    
  </entry>
  
  <entry>
    <title>分治与递归</title>
    <link href="http://jrhu05.github.io/post/divideAndConquer-part1.html"/>
    <id>http://jrhu05.github.io/post/divideAndConquer-part1.html</id>
    <published>2015-04-20T02:51:08.000Z</published>
    <updated>2015-05-07T09:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　上周学习了分治与递归的初步，莫名的有种递归恐惧感。自己调自己什么的，高中那会儿学VB学到递归的时候就觉得不正常，后来自己写代码的时候也是能不用递归就不用。</p>
<p>　　分治，没学过感觉好高大上啊，结果英文一来divide and conquer，字表其意，翻译也是屌，分而治之。</p>
<p>　　上节课主要涉及到了汉诺塔、快排、fibonacci数列什么的，实现一下。</p>
<p>　　经典的汉诺塔：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 汉诺塔问题的简单实现</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HanoiTower &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(&quot;input the N:&quot;);</span><br><span class="line">		Scanner cin=new Scanner(System.in);</span><br><span class="line">		int n=cin.nextInt();</span><br><span class="line">		hanoi(n, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	//解决的问题是将i个盘子从A移到C</span><br><span class="line">	static void hanoi(int i,char A, char B,char C)&#123;</span><br><span class="line">		if (i==1) &#123;</span><br><span class="line">			move(i, A, C);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			hanoi(i-1, A, C, B);</span><br><span class="line">			move(i, A, C);</span><br><span class="line">			hanoi(i-1, B, A, C);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static void move(int i,char x, char y)&#123;</span><br><span class="line">		System.out.println(i+&quot; from &quot;+x+&quot; to &quot;+y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　快速排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 快排的手动实现</span><br><span class="line"> * 以及快排的改进（随机化版本）的实现</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] a=&#123;2,8,7,1,3,5,6,4&#125;;</span><br><span class="line">		quickSort(a, 0, a.length-1);</span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">	&#125;</span><br><span class="line">	static void quickSort(int[] A,int p,int r)&#123;</span><br><span class="line">		if (p&lt;r) &#123;</span><br><span class="line">			int q=partition(A, p, r);</span><br><span class="line">			quickSort(A, p, q-1);</span><br><span class="line">			quickSort(A, q+1, r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static int partition(int[] A, int p, int r)&#123;</span><br><span class="line">		int x=A[r];//把最后一个元素设为主元</span><br><span class="line">		int i=p-1;</span><br><span class="line">		for(int j=p;j&lt;=r-1;j++)&#123;</span><br><span class="line">			if (A[j]&lt;=x) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				int temp=A[i];</span><br><span class="line">				A[i]=A[j];</span><br><span class="line">				A[j]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int temp=A[i+1];</span><br><span class="line">		A[i+1]=A[r];</span><br><span class="line">		A[r]=temp;</span><br><span class="line">		return i+1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static void randomQuickSort(int[] A,int p,int r)&#123;</span><br><span class="line">		if (p&lt;r) &#123;</span><br><span class="line">			int q=randomPartition(A, p, r);</span><br><span class="line">			randomQuickSort(A, p, q-1);</span><br><span class="line">			randomQuickSort(A, q+1, r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static int randomPartition(int[] A, int p, int r)&#123;</span><br><span class="line">		int randomMain=(int)(Math.random()*r);</span><br><span class="line">		int x=A[randomMain];//随机一个元素设为主元</span><br><span class="line">		int i=p-1;</span><br><span class="line">		for(int j=p;j&lt;=r-1;j++)&#123;</span><br><span class="line">			if (A[j]&lt;=x) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				int temp=A[i];</span><br><span class="line">				A[i]=A[j];</span><br><span class="line">				A[j]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int temp=A[i+1];</span><br><span class="line">		A[i+1]=A[randomMain];</span><br><span class="line">		A[randomMain]=temp;</span><br><span class="line">		return i+1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　　Fibonacci数列的非递归实现（o(n)）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 斐波那契数列的自底向上非递归算法</span><br><span class="line"> * @author jrhu05</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Fibonacci &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(&quot;input the N:&quot;);</span><br><span class="line">		Scanner cin=new Scanner(System.in);</span><br><span class="line">		int n=cin.nextInt();</span><br><span class="line">		int[] fibonacci=new int[n];</span><br><span class="line">		fibonacci[0]=fibonacci[1]=1;</span><br><span class="line">		System.out.println(fibonacci(n, fibonacci));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static int fibonacci(int index, int[] fibonacci)&#123;</span><br><span class="line">		if (index==1||index==2) &#123;</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			for (int i = 2; i &lt; fibonacci.length; i++) &#123;</span><br><span class="line">			fibonacci[i]=fibonacci[i-1]+fibonacci[i-2];</span><br><span class="line">			&#125;</span><br><span class="line">			return fibonacci[index-1];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   下节课继续是分治，问题是经典的最近点对问题，下周继续。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　上周学习了分治与递归的初步，莫名的有种递归恐惧感。自己调自己什么的，高中那会儿学VB学到递归的时候就觉得不正常，后来自己写代码的时候也是能不用递归就不用。&lt;/p&gt;
&lt;p&gt;　　分治，没学过感觉好高大上啊，结果英文一来divide and conquer，字表其意，翻译也是
    
    </summary>
    
      <category term="算法寻径" scheme="http://jrhu05.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BB%E5%BE%84/"/>
    
    
      <category term="快速排序" scheme="http://jrhu05.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
